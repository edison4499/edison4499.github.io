[{"title":"react的useEffect","date":"2020-03-09T08:00:23.000Z","path":"2020/03/09/react/useEffect/","text":"useEffect 可以在function定义的组件中模拟生命周期 参数一：表示回调函数参数二：表示什么数据改变之后会触发回调函数； 若没有参数二，表示所有数据改变都会触发参数二为空数组，表示只有在第一次组件初始化的时候会触发若参数二中的数组有值，表示数组中的数据发生改变之后会触发import React,&#123; useState,useEffect &#125; from 'react'; function CounterFun()&#123; const [ count,setCount] = useState(1); useEffect(()=&gt;&#123;console.log(\"每次都会执行\") &#125;) &#125;； useEffect(()=&gt;&#123;console.log(\"只执行一次\")；&#125;，[ ] ); useEffect(()=&gt;&#123;console.log(\"count值发生了改变\")；&#125;，[count])；//count发生改变，立即触发该生命周期 return ( &lt;div&gt; &lt;h5&gt;当前的技术值为：&#123;count&#125;&lt;/h5&gt; &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;按下&lt;/button&gt; &lt;/div&gt;) &#125;","comments":true,"tags":[]},{"title":"react的useState","date":"2020-03-09T07:00:23.000Z","path":"2020/03/09/react/useState/","text":"读取状态当 hook useState(initialState)被调用时，它返回一个数组，该数组的第一项是状态值import React, &#123; useState &#125; from 'react';function Bulbs() &#123; const stateArray = useState(false); return &lt;div&gt; &#123;stateArray[0] ? '关闭' : '开启'&#125; &lt;/div&gt;&#125; 数组解构读取状态// 咱们可以使用数组解构来将状态值提取到变量on上：import React, &#123; useState &#125; from 'react';function Bulbs() &#123; const [on] = useState(false); return &lt;div&gt; &#123;on ? '关闭' : '开启'&#125; &lt;/div&gt;&#125; 更新状态 咱们已经知道，useState(initialState)返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。import React, &#123; useState &#125; from 'react';function Bulbs() &#123; const [on, setOn] = useState(false); const lightOn = () =&gt; setOn(true); const lightOff = () =&gt; setOn(false); return ( &lt;&gt; &lt;div&gt;&#123;on ? '关闭' : '开启'&#125;&lt;/div&gt; &lt;button onClick=&#123;lightOn&#125;&gt;开灯&lt;/button&gt; &lt;button onClick=&#123;lightOff&#125;&gt;关灯&lt;/button&gt; &lt;/&gt; );&#125; 使用函数更新状态import React, &#123; useState &#125; from 'react';function Bulbs() &#123; const [on, setOn] = useState(false); const lightSwitch = () =&gt; setOn(on =&gt; !on); return ( &lt;&gt; &lt;div&gt;&#123;on ? '开启' : '关闭'&#125;&lt;/div&gt; &lt;button onClick=&#123;lightSwitch&#125;&gt;开灯/关灯&lt;/button&gt; &lt;/&gt; );&#125; 总结 调用useState() Hook 来启用函数组件中的状态。 useState(initialValue)的第一个参数initialValue是状态的初始值。 [state, setState] = useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。 使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev =&gt; next)来调用状态更新器，该调将返回基于先前状态的新状态。 调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。 多种状态 通过多次调用useState()，一个函数组件可以拥有多个状态。import React from 'react'import &#123; useState &#125; from 'react'function App() &#123; const [on, setOn] = useState(false); const [count, setCount] = useState(1); const lightSwitch = () =&gt; setOn(on =&gt; !on); const addBulbs = () =&gt; setCount(count =&gt; count + 1); const bulb = &lt;div&gt;&#123;on ? '开启' : '关闭'&#125;&lt;/div&gt; const bulbs = Array(count).fill(bulb); return ( &lt;div&gt; &lt;div className=\"bulbs\"&gt;&#123;bulbs&#125;&lt;/div&gt; &lt;button onClick=&#123;lightSwitch&#125;&gt;开/关&lt;/button&gt; &lt;button onClick=&#123;addBulbs&#125;&gt;添加灯泡&lt;/button&gt; &lt;/div&gt; );&#125; 状态的延迟化每当 React 重新渲染组件时，都会执行useState(initialState)。 如果初始状态是原始值（数字，布尔值等），则不会有性能问题。当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，如下所示：import React from 'react'import &#123; useState &#125; from 'react'function App() &#123; const [on, setOn] = useState(() =&gt; &#123; return [1, 2, 3, 4, 5] &#125;); return ( &lt;div&gt; &#123; on &amp;&amp; on.map((i, index) =&gt; &#123; return &lt;p&gt;&#123;i&#125;&lt;/p&gt; &#125;) &#125; &lt;/div&gt; );&#125;export default App useState中的坑 useState() 的无效调用 // 在条件中调用useState()是不正确的：function Switch(&#123; isSwitchEnabled &#125;) &#123; if (isSwitchEnabled) &#123; // Bad const [on, setOn] = useState(false); &#125;&#125; 在嵌套函数中调用useState()也是不对的 function Switch() &#123; let on = false; let setOn = () =&gt; &#123;&#125;; function enableSwitch() &#123; // Bad [on, setOn] = useState(false); &#125; return ( &lt;button onClick=&#123;enableSwitch&#125;&gt; Enable light switch state &lt;/button&gt; );&#125; 过时状态闭包（例如事件处理程序，回调）可能会从函数组件作用域中捕获状态变量。 由于状态变量在渲染之间变化，因此闭包应捕获具有最新状态值的变量。否则，如果闭包捕获了过时的状态值，则可能会遇到过时的状态问题。来看看一个过时的状态是如何表现出来的。组件延迟3秒计数按钮点击的次数。 function DelayedCount() &#123; const [count, setCount] = useState(0); const handleClickAsync = () =&gt; &#123; setTimeout(function delay() &#123; setCount(count + 1); &#125;, 3000); &#125; return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;handleClickAsync&#125;&gt;Increase async&lt;/button&gt; &lt;/div&gt; );&#125; delay() 是一个过时的闭包，它从初始渲染（使用0初始化时）中捕获了过时的count变量。为了解决这个问题，使用函数方法来更新count状态： function DelayedCount() &#123; const [count, setCount] = useState(0); const handleClickAsync = () =&gt; &#123; setTimeout(function delay() &#123; setCount(count =&gt; count + 1); &#125;, 3000); &#125; return ( &lt;div&gt; &#123;count&#125; &lt;button onClick=&#123;handleClickAsync&#125;&gt;Increase async&lt;/button&gt; &lt;/div&gt; );&#125;export default DelayedCount React 确保将最新状态值作为参数提供给更新状态函数，过时闭包的问题解决了。","comments":true,"tags":[]},{"title":"js的运行机制","date":"2020-03-03T07:00:23.000Z","path":"2020/03/03/js高级进阶/js的运行机制/","text":"js运行机制JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs ，macrotask 称为 task //以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。微任务包括 process.nextTick ， promise ， Object.observe ， MutationObserver宏任务包括 script ， setTimeout ， setInterval ， setImmediate ， I/O ， UI rendering console.log('script start')setTimeout(function() &#123; console.log('setTimeout') &#125;, 0) new Promise(resolve =&gt; &#123; console.log('Promise') resolve() &#125;) .then(function() &#123; console.log('promise1') &#125;) .then(function() &#123; console.log('promise2') &#125;) console.log('script end') // script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的界面响应，我们可以把操作 DOM 放入微任务中。","comments":true,"tags":[]},{"title":"js防抖和节流","date":"2020-02-26T07:00:23.000Z","path":"2020/02/26/js高级进阶/防抖和节流/","text":"防抖的理解当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时 function debounce(fn, wait) &#123; var timeout = null; //定义一个定时器 return function() &#123; if(timeout !== null) clearTimeout(timeout); //清除这个定时器 timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件// window.addEventListener('scroll', debounce(handle, 1000));document.getElementById('button').onclick = debounce(handle, 3000) 节流的理解当持续触发事件时，保证一定时间段内只调用一次事件处理函数 // 用时间戳来实现var throttle = function(func, delay) &#123; var lastTime = 0 return function() &#123; var context = this; //this指向window var args = arguments; var now = Date.now(); if (now - lastTime &gt;= delay) &#123; func.apply(context, args); lastTime = now &#125; &#125;&#125;function handle() &#123; console.log(Math.random());&#125;// window.addEventListener('scroll', throttle(handle, 1000));document.getElementById('button').onclick = throttle(handle, 3000)// 用定时器来实现function handle() &#123; console.log(Math.random());&#125;function throttle(fn,delay)&#123; let valid = true return function() &#123; if(!valid)&#123; //休息时间 暂不接客 return false &#125; // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false fn() setTimeout(() =&gt; &#123; valid = true; &#125;, delay) &#125;&#125;// window.addEventListener('scroll', throttle(handle, 1000));document.getElementById('button').onclick = throttle(handle, 3000)","comments":true,"tags":[]},{"title":"单例模式","date":"2020-02-06T08:41:23.000Z","path":"2020/02/06/js设计模式/单例模式/","text":"通用惰性单例 以创建页面上的一个弹窗为例var createLoginLayer = (function()&#123; var div; return function()&#123; if ( !div )&#123; div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); &#125; return div; &#125; &#125;)();document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block'; &#125;; 上面传统单例模式带来的弊端是 加入页面还要嵌入一个iframe那么以上代码几乎要重新写一遍var createIframeLayer = (function()&#123; var iframe; return function()&#123; if ( !iframe )&#123; iframe = document.createElement( 'iframe' ); iframe.style.display = 'none'; document.body.appendChild( iframe ); &#125; return iframe; &#125; &#125;)();document.getElementById( 'iframeBtn' ).onclick = function()&#123; var iframeLayer = createIframeLayer(); iframeLayer.style.display = 'block'; &#125;; 我们可以利用闭包把真正的单例模式的核心代码抽离出来// 把单例模式的核心代码抽离出来 // 这里面巧妙的用到了闭包的功能 var getSingle = function( fn )&#123; var result; return function()&#123; return result || ( result = fn .apply(this, arguments ) ); &#125; &#125;; var createLoginLayer = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div; &#125;; var createSingleLoginLayer = getSingle( createLoginLayer ); document.getElementById( 'loginBtn' ).onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; &#125;;","comments":true,"tags":[]},{"title":"vscode解决乱码的方法","date":"2020-01-09T08:36:10.000Z","path":"2020/01/09/其他/解决乱码的问题/","text":"下载一个插件即可 插件的名字是 GBKtoUTF8","comments":true,"tags":[]},{"title":"caller和callee的区别","date":"2020-01-09T08:02:23.000Z","path":"2020/01/09/js高级进阶/caller和callee的区别/","text":"caller的理解 caller 返回一个调用当前函数的引用 如果是由顶层调用的话 则返回nullvar callerTest = function()&#123; console.log(callerTest.caller);// 这里输出是谁调用了你 就输出谁 &#125;function a()&#123; callerTest()&#125;a() // 输出function a() &#123;callerTest();&#125; callee的理解 callee返回以个正在被执行函数的引用(常用在递归匿名函数本身) callee是arguments对象的一个成员 表示对函数对象本身的引用 它有个length属性（代表形参的长度）var c = function(x,y)&#123; console.log(arguments.length,arguments.callee.length,arguments.callee) // 3 2 ƒ (x,y)&#123; // console.log(arguments.length,arguments.callee.length,arguments.callee) // // 实参长度 形参长度 函数本身的引用 // &#125; // 实参长度 形参长度 函数本身的引用&#125;c(1,2,3)","comments":true,"tags":[]},{"title":"严格模式和非严格模式","date":"2020-01-07T07:56:23.000Z","path":"2020/01/07/js高级进阶/严格模式和非严格模式/","text":"严格模式理解在es3.0和es5.0起冲突后严格模式下会使用es5.0 不允许使用argument.callee'use strict'function test()&#123; console.log(arguments.callee);// 在es3.0里面不会出错指向的是函数的引用 // 使用严格模式后会报错 console.log(124);&#125;test() 不允许用caller// 'use strict' // 严格模式下会报错function test()&#123; console.log(test.caller); // ƒ demo()&#123; test()&#125;&#125;function demo()&#123; test()&#125;demo() 不允许用with with如果括号里面不加对象的话正常执行如果加了对象之后会把这个对象当做执行代码体的作用域链的最顶端（会改变作用域链) 注意一般不用with因为会重新改变作用域影响性能 with(document)&#123; write('a')&#125;var obj = &#123; name:'obj'&#125;var name = 'window'function test()&#123; 'use strict' // 此时加上严格模式之后会报错 var name = 'scope' with(obj)&#123; console.log(name); // 会是obj &#125;&#125;test() 函数里面的this不再是window'use strict'function test()&#123; console.log(this); // 严格模式下会是undefined 非严格模式下是window&#125;test()// 严格模式下面的this要想有值必须被赋值 // 当变成new test() 的时候this指的就是test构造函数// 'use strict' // function Test()&#123; console.log(this); // 非严格模式下会是数值包装类Number &#123;123&#125; // 严格模式下直接就是123了 你传什么就是什么&#125;Test.call(123) 重复的函数参数// es3里面可以这么写重复的参数不会报错但是在es5里面会报错// 'use strict' 严格模式会报错function test(name,name)&#123; console.log(name);&#125;test(1) 重复的属性// es3里面可以这么写重复的参数不会报错但是在es5里面会报错'use strict' // 严格模式会报错 但是浏览器不报错 这就是浏览器和es标准之间的一个误差了var obj = &#123; name:'zs', name:'ls'&#125;","comments":true,"tags":[]},{"title":"es6箭头函数的使用场景","date":"2020-01-07T02:14:53.000Z","path":"2020/01/07/es6/es6箭头函数的使用场景/","text":"箭头函数的使用var f= v=&gt;vconsole.log(f(2)); // var f = function(v)&#123;// return v// &#125;var sum = (num1,num2)=&gt;num1 + num2// 一旦写了大括号 就一定要returnvar get = (a,b)=&gt;&#123; var c = a+b; var d = c+5 return d&#125; 适用场景场景一function Person()&#123; this.name = 'tony' this.say = function()&#123; console.log(`我叫$&#123;this.name&#125;`); &#125;&#125;var person1 = new Person()// person1.say()var res = person1.sayres() // 此时这种写法不会输出名字 原因是保存到了外部this指向丢失// 解决办法一function Person()&#123; this.name = 'tony' var that = this this.say = function()&#123; console.log(`我叫$&#123;that.name&#125;`); &#125;&#125;// 解决办法二function Person()&#123; this.name = 'tony' this.say = function()&#123; console.log(`我叫$&#123;this.name&#125;`); &#125; this.say = this.say.bind(this)&#125;// 解决办法三function Person()&#123; this.name = 'tony' this.say =()=&gt;&#123; console.log(`我叫$&#123;this.name&#125;`); &#125;&#125; 场景二class Person &#123; eat()&#123; this.get() &#125; get()&#123; console.log('食物'); &#125;&#125;let person1 = new Person()let &#123;eat&#125; = person1;eat() // 此时不会输出食物 // 解决办法一class Person &#123; constructor()&#123; this.eat = this.eat.bind(this) &#125; eat()&#123; this.get() &#125; get()&#123; console.log('食物'); &#125;&#125;// 解决办法二 class Person &#123; eat = ()=&gt;&#123; this.get() &#125; get()&#123; console.log('食物'); &#125;&#125;// 对于上面出现问题的代码有疑问？？ class Person &#123; eat()&#123; console.log(this) this.get() &#125; get()&#123; console.log('食物'); &#125;&#125;// 此时在99行打印出的结果是undefined 按道理来说应该是window才对// 原因是因为在class类的内部默认使用了严格模式 所谓严格模式就是'use strict'// class类里面的方法其实是定义到原型对象上面的 所以可以改写代码如下// 'use strict'class Person&#123; constructor()&#123; // this.eat = this.eat.bind(this) &#125;&#125;Person.prototype.get = function()&#123; console.log('食物');&#125;Person.prototype.eat = function()&#123; console.log(this); this.get()&#125;let person1 = new Person();let &#123;eat&#125; = person1;eat()// 此时输出的this就是window 但是一旦把上面的use strict注释放开的话 就是undefined了// 再比喻我们函数的调用 加上严格模式之后里面的this就是undefined 放开的话就是window'use strict'function get()&#123; console.log(this);&#125;get() 场景3回调函数var handel = &#123; id:123, init:function()&#123; setTimeout(()=&gt;&#123; this.doSomeThing() &#125;,1000) &#125;, doSomeThing:function()&#123; console.log(`初始化id是$&#123;this.id&#125;`); &#125;&#125;handel.init() 不适用场景场景1&lt;button id=\"btn\"&gt;点击&lt;/button&gt;var btn = document.querySelector(\"#btn\")btn.onclick = function()&#123; console.log(this.innerText); &#125;// 错误使用// btn.onclick = ()=&gt;&#123;// console.log(this.innerText);// &#125; 场景2let cat = &#123; lives:9, jumps:function()&#123; this.lives -- &#125; // 错误用法 // jumps:()=&gt;&#123; // this.lives -- // &#125;&#125;cat.jumps()console.log(cat.lives); vue里面的使用场景 &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"浪起来\" @click=\"lang\"&gt; &lt;input type=\"button\" value=\"低调\" @click=\"stop\"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt;&lt;/div&gt; // 注意：在 VM实例中，如果想要获取 data 上的数据，或者 想要调用 methods 中的 方法，必须通过 this.数据属性名 或 this.方法名 来进行访问，这里的this，就表示 我们 new 出来的 VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义 定时器Id &#125;, methods: &#123; lang() &#123; if (this.intervalId != null) return; var that = this this.intervalId = setInterval(function()&#123; var start = that.msg.substring(0, 1) // 获取到 后面的所有字符 var end = that.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg that.msg = end + start &#125;, 400) &#125;, stop() &#123; // 停止定时器 clearInterval(this.intervalId) // 每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) react里面的使用场景&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script src=\"./js/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/react-dom.development.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/babel.min.js\"&gt;&lt;/script&gt; // &lt;script type=\"text/babel\"&gt; class App extends React.Component&#123; // 解决办法一 // constructor(props)&#123; // super(props) // this.click = this.click.bind(this) // &#125; get()&#123; console.log('我是食物'); &#125; // 解决办法二 click = ()=&gt;&#123; this.get() &#125; render()&#123; return ( &lt;button onClick=&#123;this.click&#125;&gt;获取&lt;/button&gt; ) &#125; &#125; ReactDOM.render(&lt;App /&gt;,document.getElementById(\"app\"))// &lt;/script&gt; 总结箭头函数里面的this由动态变成静态（this指向变成在定义箭头函数时候的this的指向）适用场景1 有一个简短语句表达式 唯一的语句就是return2 函数内部没有this引用 并且没有自身的引用 (递归)3 有一个内层的函数表达式 需要这么来处理 var that = this 用到bind这种处理 可以用箭头函数4 回调函数不适用场景定义了对象的方法 方法内部包括thisdom的操作","comments":true,"tags":[]},{"title":"快速删除node_modules目录的方法","date":"2020-01-01T08:36:10.000Z","path":"2020/01/01/其他/快速删除node_modules文件的方法/","text":"第一种方法 cnpm i rimraf -g rimraf node_modules 第二种方法 rmdir /s/q your_app_dir 第三种 rm -f /node_modules 第四种 cnpm install -g dlf dlf C:\\Users\\92809\\Desktop\\56（这里是node_modules的文件全路径）","comments":true,"tags":[]},{"title":"es6-Map数据结构Iterator接口","date":"2019-12-16T04:18:53.000Z","path":"2019/12/16/es6/es6-map数据结构Iterator接口/","text":"Map是什么// map????// es6 新提出的一种引用类型的数据结构 类似于对象// 字符创-》值 值-》值 声明Map数据结构const map = new Map()const o = &#123;p:'hello'&#125; // 相当于键 key map.set(o,'content') // var a = &#123;&#125; a.name = '张三' a.nameconsole.log(map.get(o)); 证明是引用数据类型// null typeof null const map = new Map()console.log(map instanceof Map); // true console.log(Object.prototype.toString.call(map) === '[object Map]'); 接收数组作为参数const map = new Map( [ ['name','张三'], ['age',18] ]) console.log(map.get('name')); // 张三 console.log(map.get('age')); // 18 // map 是数组的方法 Map 是es6新提出的一种新的 引用类型的数据结构 const m = new Map( [ [123,'abc'], ['a',&#123;x:1,y:2&#125;], [3&gt;1,666] ] ) console.log(m.get(true)); // 666 // 404 Not found 500 InterError 404和500 都是数值 let errors = new Map([ [404,'Not found'], [500,'InterError'] ]) // 注意 对象作为键名 传输的是地址 // let m1 = new Map([ // [123,'abc'], // [&#123;x:1&#125;,'cdf'] // ]) // console.log(m1.get(&#123;x:1&#125;)); // undefined let obj1 = &#123;x:1&#125; let m1 = new Map([ [123,'abc'], [obj1,'cdf'] ]) console.log(m1.get(obj1)); // cdf Map接收数组作为参数的本质// 为什么 接收一个二元数组 key value的形式 就可以通过 map.get()获取到值呢const array = [ ['name','张三'], ['age',18]]const map = new Map()array.forEach( ([key,value])=&gt;map.set(key,value)) Map参数的扩展// 具有迭代器 iterator 接口 每个成员都是双元素的数组的数据结构 都可以当做map构造函数的参数 Iterator 和 for…of 循环为什么要有iterator？？// Map Set 等数据结构 需要一个统一的接口去处理 iterator就是提供了这么一个机制 作用// 数据部署了iterator接口 就可以用for ... of 循环遍历 for…of 循环的遍历过程的本质// for...of 循环遍历的过程 // 1 创建一个指针对象 指向数据的初始位置 iterator就是一个指针对象 // 2 第一次调用指针对象的next() 可以将指针指向第一个成员 // ..... // 直到结束 // !!!! 每一次调用指针对象的时候每次调用next()方法 会返回 value 指的是值 done是布尔值 用来标识遍历是否完成 const arr = [1,2] function makeIterator(array)&#123; let nextIndex = 0; return &#123; next:function()&#123; return nextIndex &lt; array.length ? &#123; value:array[nextIndex++], done:false &#125; :&#123; value:undefined, done:true &#125; &#125; &#125; &#125; let res = makeIterator(arr) console.log(res.next()); console.log(res.next()); console.log(res.next()); console.log(res.next()); Iterator接口部署在数据结构的Symbol.iterator属性// 重中之重let arr1 = [1,2,3,4,5] // let iter = arr1[Symbol.iterator]() // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); 原生具备Iterator接口的数据结构具有iterator接口 Array Map Set String 对象不具备Iterator接口 可以手动部署迭代器接口 让其可以用for…of 循环遍历// 想让对象也可以通过for...of 循环遍历 let obj = &#123; data:[1,2,3,4], [Symbol.iterator]()&#123; let index = 0 let that = this return &#123; next()&#123; if(index&lt;that.data.length)&#123; return &#123; value:that.data[index++], done:false &#125; &#125;else&#123; return &#123; value:undefined, done:true &#125; &#125; &#125; &#125; &#125; &#125; for (let i of obj )&#123; console.log(i); &#125;","comments":true,"tags":[]},{"title":"es6-函数扩展和箭头函数","date":"2019-12-16T04:18:53.000Z","path":"2019/12/16/es6/es6函数扩展箭头函数/","text":"函数扩展函数参数的默认值// 函数参数的默认值 // function get(x,y)&#123; // // 让你把y指定默认值为 '默认值' // y = y || '默认值' // console.log(x); // console.log(y); // &#125; // get(1) // 弊端 当传0的时候 打印不出实参0 // 怎么解决这个弊端？？？ // function get(x,y)&#123; // // 让你把y指定默认值为 '默认值' // if(typeof y === undefined)&#123; // y = '默认值' // &#125; // console.log(x); // console.log(y); // &#125; // get(1) // function get(x,y='默认值')&#123; // console.log(x); // console.log(y); // &#125; // get(1) function Person(name = '张三',age=18)&#123; this.name = name this.age = age &#125; let person1 = new Person() console.log(person1); // 好处 // 1 阅读代码清晰 // 2 有利于代买维护 有利于封装代码 // 注意：有默认参数声明 内部不能用let const声明 function fn(x,y=\"123\")&#123; let x = 1; &#125; fn(1) 与结构赋值结合的使用function fn(&#123;x,y=5&#125;)&#123; console.log(x); console.log(y); &#125; fn(&#123;&#125;) // undefined 5 fn(&#123;x:1&#125;) fn(&#123;x:1,y:9&#125;) // 对象解构赋值的等号的右边必须是对象 // 接口 // function api(&#123;name,pass&#125;)&#123; // // 拿到请求的数据 // console.log(name); // console.log(pass); // // 发请求 // &#125; // // 调用这个方法的数据是表单获取的数据 // // obj = &#123;name:'张三',pass:'123'&#125; // api(&#123;name:'张三',pass:'123'&#125;) function getFn([x=3,y=5])&#123; console.log(x); console.log(y); &#125; getFn([1]) function getFn([x=3,y=5] = [1])&#123; console.log(x); console.log(y); &#125; getFn() 参数默认值会形成单独的作用域// 函数的参数会形成一个单独的作用域 // 等到初始结束这个作用域就会消失 // var x =1; // function f(x,y=x)&#123; // console.log(y); // &#125; // f(2) // 相当于形成了一个单独的块级作用域 // &#123; // let x = 2 // y = x // &#125; // let x = 1; // // 相当于形成了一个单独的块级作用域 // &#123; // let y = x // console.log(y); // &#125; // function ff(y = x)&#123; // let x = 2; // console.log(y); // &#125; // function fy(y= x)&#123; // let x = 2; // console.log(y); // &#125; // fy() // 会报错 x is not defined var x = 1; // &#123; // let x = x // &#125; // function fg(x = x)&#123; // &#125; // fg() 参数展开运算符打包// 写一个方法计算 1,2,3相加的结果 用到for...of 循环 // 第一种方法 // function add()&#123; // // console.log(arguments); // // ... Array.from() // let sum = 0 // for (let i of arguments)&#123; // console.log(i); // sum += i // &#125; // return sum // &#125; // console.log(add(1,2,3)); // 第二种方法 参数展开运算符打包 function add(...values)&#123; console.log(values); let sum = 0 for (let i of values)&#123; console.log(i); sum += i &#125; return sum &#125; console.log(add(1,2,3)); 函数内部严格模式的改变// es6 函数参数指定了默认值 解构赋值 扩展运算符... 内部就不能用严格模式 ?? // 为什么 // 因为我们的参数此时也会形成一个作用域 // function get(a,b = a)&#123; // 'use strict' // &#125; // get() // ???怎么解决 // 方法一 'use strict' function get(a,b = a)&#123; &#125; get() // 方法二 const doSome = (function()&#123; 'use strict' return function(a = 2)&#123; return 2 &#125; &#125;()) 箭头函数基本用法// const f = v=&gt;v // 相当于 // const f = function(v)&#123; // return v // &#125; console.log(f(1)); // 箭头函数 // 有参数的时候 // const f = v=&gt;v // 相当于 // const f = function(v)&#123; // return v // &#125; // console.log(f(1)); // 没有参数 多个参数 需要用() 包裹起来 const fn = ()=&gt;5 console.log(fn()); const fnG = (num1,num2)=&gt;num1 + num2 console.log(fnG(1,2)); // 函数块的语句 多于一条语句的 要使用&#123;&#125; 包裹起来 并且要用return 返回 const fJ = (a,b)=&gt;&#123; let c = a+b; let d = c+19; return d &#125; console.log(fJ(1,7)); // 注意 返回的是一个对象 &#123;&#125; 此时应该怎么处理 必须要在对象的外面加括号 // let getObj = ()=&gt;(&#123;name:'张三',age:18&#125;) // console.log(getObj()); // let getObj = ()=&gt;&#123; // return &#123; // name:'张三',age:18 // &#125; // &#125; // console.log(getObj()); 注意点// 1 this 也是箭头函数作用最大的地方 this不再是动态的 定义时候所在的对象而不是使用时所在的对象 // 2 箭头函数不能当做构造函数 不能new // 3 箭头函数内部不能用 arguments // 4 不能够当做 generator函数 不能加yield命令 实例演示// 见跑马灯的代码// Person.prototype.say = ()=&gt;&#123; // console.log(`我的名字是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁了`); // &#125; // function Person()&#123; // this.name = '张飞' // this.age = 33 // &#125; // let person1 = new Person() // person1.say() // const hander = &#123; // id:12, // init:function()&#123; // setTimeout(()=&gt;&#123; // console.log(this); // this.doSome() // &#125;,1000) // &#125;, // doSome:function()&#123; // console.log(`初始化的id为$&#123;this.id&#125;`); // &#125; // &#125; // hander.init() function Person()&#123; this.name = '张三' this.say = function()&#123; console.log(`这是我的名字$&#123;this.name&#125;`); &#125; this.say = this.say.bind(this) // this.say = ()=&gt;&#123; // console.log(`这是我的名字$&#123;this.name&#125;`); // &#125; &#125; let person = new Person() let res = person.say res() // 为以后学习react 打下基础 学习class打下基础 使用时机// 箭头函数的使用时机 // 1 如果说有一个简短的语句 返回是一个简单的表达式 return num + num 2 函数内部没有this的引用 // 也没有自身的引用 (递归) // 2 内部需要 调用vat self = this 调用 bind 也适用于箭头函数 // 3 只要是回调函数 99% 用箭头函数就没有错","comments":true,"tags":[]},{"title":"webpack之splitChunks的配置详解","date":"2019-12-16T04:00:53.000Z","path":"2019/12/16/webpack/splitChunks的配置详解/","text":"optimization:&#123; splitChunks:&#123; chunks: 'all', // all 所有 async 异步 initial 同步 minSize: 30000,// 最小的字节大小这里是30kb // maxSize: 0,// 最大的 这一项一般不用 意思是假设打包的有1mb 这里设置500000 // 会尝试进行二次的拆分 minChunks: 1, // 引入的块的最小值 比如说这里只引入了lodash如果这里改成2的话 就不会做代码分割了 maxAsyncRequests: 6,// 最大的代码分割数 比如说你引入了7个 但是这里设置6 只会对前6个做分割 maxInitialRequests: 4,// 整个网站首页加载的时候的最大引入数 automaticNameDelimiter: '~', // 打包后文件名字的连接符号 automaticNameMaxLength: 30, // 设置块名称的最大字符 name:true, // 指的是下面的filename的名字生效 cacheGroups: &#123; // 缓存组 代码分割后的非业务逻辑代码打包到一起 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, //检测是否在node_modules目录 priority: -20, // 这个是优先级和下面default的priority做对比 // 引入的lodash符合在nodemodules下面 // filename:'[name].bundle.js' name:'vendor' &#125;, default: &#123;// 检测的是没有在node_modules 目录下的时候的处理 minChunks: 2,// 引入块的最小值 priority: -10,// 优先级 // 引入的lodash也符合在default 所有的模块都符合 此时就是比较权重了 // 注意哪怕这里的权重比上面的高 但是被上面的test匹配到了之后还是会走上面的 reuseExistingChunk: true, // 比如说有两个模块 a 和 b a里面引入的有b // 正常来说打包a的话会把b也打包进去 // 但是假如说以前b已经被打包过了 那么就不会再次被打包进去了 name:'common' &#125; &#125; &#125;&#125;","comments":true,"tags":[]},{"title":"webpack之code-spliting","date":"2019-12-12T04:00:53.000Z","path":"2019/12/12/webpack/webpack-codeSpliting/","text":"好比说项目中引入了lodashlodash 和 我们的逻辑代码就可以做一个分割 优点每次加载的文件的大小基本没变 只不过分两次加载但是由于浏览器有缓存的原因 比如第三方的lodash分开加载的话由于浏览器缓存的原因没有做改变的话是不会重新加载的这样一来就增加了开发效率 在webpack中的配置截图如下","comments":true,"tags":[]},{"title":"es6-reflect","date":"2019-12-10T09:25:53.000Z","path":"2019/12/10/es6/es6-reflect/","text":"Reflect是什么？为操作对象而提供的新API 为什么要设计Reflect？ 将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。 让Object操作变成函数行为// 以前const obj = &#123;name:'张三'&#125;console.log('name' in obj); // true// 现在console.log(Reflect.has(obj,'name')); // true Reflect 与 Proxy 是相辅相成的 在Proxy上有的方法 在 Reflect上就一定有Reflect的api 和proxy的api一致 Reflect.get(target,property,receiver)查找并返回target对象的property属性let obj=&#123; name:\"chris\",&#125;let result=Reflect.get(obj,\"name\")console.log(result) //chrislet obj=&#123; //属性yu部署了getter读取函数 get yu()&#123; //this返回的是Reflect.get的receiver参数对象 return this.name+this.age &#125;&#125;let receiver=&#123; name:\"shen\", age:\"18\",&#125;let result=Reflect.get(obj,\"yu\",receiver)console.log(result) //shen18 Reflect.set(target,propName,propValue,receiver)设置target对象的propName属性为propValuelet obj=&#123; name:\"chen\"&#125;let result=Reflect.set(obj,\"name\",\"shi\")console.log(result) //trueconsole.log(obj.name) //shilet obj=&#123; age:38, set setAge(value)&#123; return this.age=value &#125;&#125;let receiver=&#123; age:28&#125;let result=Reflect.set(obj,\"setAge\",18,receiver)console.log(result) //trueconsole.log(obj.age) //38console.log(receiver.age) //18 Reflect.set与Proxy.set联合使用let obj=&#123; name:\"chen\"&#125;let handler=&#123; set(target,key,value,receiver)&#123; console.log(\"Proxy拦截赋值操作\") //Reflect完成赋值操作 Reflect.set(target,key,value,receiver) &#125;, defineProperty(target,key,attribute)&#123; console.log(\"Proxy拦截定义属性操作\") //Reflect完成定义属性操作 Reflect.defineProperty(target,key,attribute) &#125;&#125;let proxy=new Proxy(obj,handler)proxy.name=\"ya\"//Proxy拦截赋值操作//Proxy拦截定义属性操作","comments":true,"tags":[]},{"title":"es6-对象的扩展Symbol Set数据结构","date":"2019-12-09T02:22:53.000Z","path":"2019/12/09/es6/es6对象的扩展Symbol-Set数据结构/","text":"对象的扩展方法属性的简写const a = 'a';const obj = &#123;a&#125;// const obj = &#123;a:a&#125;console.log(obj); 方法的简写const o = &#123; say()&#123; return '我是chris' &#125;&#125;console.log(o.say());// 谁用我我就指向谁var name = '全局'const person = &#123; name:'张三', say()&#123; console.log(`我的名字是$&#123;this.name&#125;`); &#125;&#125;person.say()let res = person.say; // 全局res() 属性名表达式let obj1 = &#123; // 让属性和变量挂钩 [key]:true, ['o'+'b']:123, [`ok`]:456&#125;console.log(obj1); super 关键字const proto = &#123; foo:'土豆'&#125;// const oProto = &#123;// foo:'西红柿',// find()&#123;// return super.foo// &#125;// &#125;// // proto 是 oProto的原型// Object.setPrototypeOf(oProto,proto) // __proto__// console.log(oProto.find()); // // const oProto = &#123;// foo:super.foo// &#125; 对象的扩展运算符 …打包// 打包// let &#123;x,y:y,...z&#125; = &#123;x:1,y:2,a:3,b:4&#125;// console.log(z);// 等号的右边必须是一个对象 // let &#123;...h&#125; = undefined// let &#123;...v&#125; = null// 数组的解构赋值 ... 有一个注意点 是...的位置// let &#123;...z,x,y&#125; = &#123;x:1,y:2,a:3,b:4&#125; 拆包// 复制 浅拷贝 深拷贝 // 数组的浅拷贝es5 用到的是什么 concat // 对象的扩展运算符 ...也是浅拷贝 // 复制 // let obj = &#123;a:1&#125; // // let obj1 = obj; // // obj1.a = 2; // // console.log(obj); // // 浅拷贝 // let obj1 = &#123;...obj&#125; // obj1.a = 2; // console.log(obj); // // es5 实现浅拷贝 类比concat // let person = &#123;name:'张三',age:12&#125; // let person2 = Object.assign(&#123;&#125;,person) // person2.name = '王五' // console.log(person); // let &#123;a,b,...z&#125; = &#123;c:1,b:2,a:3,d:4&#125; // console.log(z); // 是不是深拷贝？ 不是！！！ let obj = &#123;a:&#123;b:1&#125;&#125; let obj1 = &#123;...obj&#125; obj1.a.b =2; console.log(obj); Symbol数据结构概念以及引入的原因// 新提出的一个数据结构 Symbol 基本数据类型 // Symbol表示独一无二 第七种数据类型 // 作用？ // 对象的属性是字符串 对象的话隐式调用toString 转化成字符串 let a = &#123;a:1&#125;; let b = &#123;b:2&#125;; let c = &#123;&#125;; c[a] = 3; // [object Object] c[b] = 4; // [object Object] console.log(c); // ? 怎么解决 let s = Symbol() console.log(typeof s); // 第七种一般数据类型 接收字符串作为参数let s1 = Symbol('a') let s2 = Symbol('b') console.log(s1); console.log(s2); console.log(s1.toString()); console.log(s2.toString()); let s3 = Symbol(&#123;&#125;) console.log(s3); // 传入的参数只是值得描述 即使传入的值是一样的 返回值也是不相等的 let s4 = Symbol() let s5 = Symbol(); console.log(s4 === s5); let s6 = Symbol('a') let s7 = Symbol('a'); console.log(s6 === s7); 不能与其他类型的值进行计算let sym = Symbol('my Symbol') 'my symbol is' + sym Symbol可以显示转化为字符串let s1 = Symbol('a')let s2 = Symbol('b')console.log(s1);console.log(s2);console.log(s1.toString());console.log(String(s1)); Symbol可以转为布尔值 但是不能转化成数值 let symb = Symbol();console.log( !Boolean(symb)); Symbol.iterator 属性对象的Symbol.iterator属性 指向该对象的默认遍历器的方法 for...of 循环的时候会调用Symbol.iterator Object.getOwnPropertySymbols()const obj = &#123;&#125;; let sym1 = Symbol('a') let sym2 = Symbol('b') obj[sym1] = 'hello' obj[sym2] = 'world' // Object.getOwnPropertySymbols() 返回一个数组 里面的值是所有用作属性名的Symbol的值 const arr = Object.getOwnPropertySymbols(obj) console.log(arr); 作用实例 常量枚举 私有属性// // js没有枚举类型 用到枚举案例的时候可以用到 Symbol类型// const CODE_ONE = 1; // 汽车的颜色 红色// const CODE_TWO = 1;// 蓝色// const CODE_THREE = 3;// 黑色// const CODE_ONE = Symbol('a'); // 汽车的颜色 红色// const CODE_TWO = Symbol('b');// 蓝色// const CODE_THREE = Symbol('b');// 黑色// // 会实现私有属性 const private = Symbol('private') const obj = &#123; // 私有属性 _name:'张三', [private]:'私有的属性' &#125; console.log(Object.keys(obj)); // 到底怎么实现私有属性呢？ class 里面的一些东西 会详细讲到 Set数据结构Set是什么// Set是es6新提出的一个新的引用数据类型 类似于数组 但是成员是唯一的 没有重复的值// 和对象里面的 get set 不一样 基本用法// 基本用法 const set = new Set([1,2,3,4,5,6,5]) console.log(set); 证明set是js新的引用数据类型let arr = [1,2,3,4]let obj = &#123;name:'张三'&#125;let nu = null // 历史遗留问题console.log(typeof arr);console.log(typeof obj);console.log(typeof nu);// 证明 arr是数组 obj 是对象// instanceof // Object.prototype.toString.call(arr)console.log(arr instanceof Array);console.log(obj instanceof Object);console.log(Object.prototype.toString.call(arr)); // string [object Array]console.log(Object.prototype.toString.call(obj)); // string [object Object]const set = new Set([1,2,3,4,5,6,5])console.log(set instanceof Set);console.log(Object.prototype.toString.call(set) === '[object Set]'); 转化成数组// 转化成数组 const set = new Set([1,2,3,4,5,6,5]) // 数组去重的方法 console.log([...set]); console.log(Array.from(set)); Set数据内部判断值得机制// Set数据内部判断值得机制 类似于 === let newSet = new Set() let a = 5; let b = '5' newSet.add(a) newSet.add(b) // ? 里面有几项 ？ console.log(newSet); // 特殊情况NaN // 因为 NaN === NaN newSet.add(NaN) newSet.add(NaN) console.log(newSet); Set实例的属性和方法Set的属性let lastSet = new Set()lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN)console.log(lastSet.size); add delete has clearlet lastSet = new Set() lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN) console.log(lastSet.size); // 判断是否有这一项 console.log(lastSet.has(2)); lastSet.clear() console.log(lastSet); 方法forEach()let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9","comments":true,"tags":[]},{"title":"es6-字符串数组的扩展方法","date":"2019-12-07T05:05:53.000Z","path":"2019/12/07/es6/es6字符串数组的扩展/","text":"字符串的扩展方法模板字符串简便换行和嵌入变量操作// 简便换行 let s1 = '我爱我的祖国\\n和我的母亲' console.log(s1); let s2 = `我爱我的祖国和我的母亲` console.log(s2); let a = '和我的母亲' let b = '我爱我的祖国'+a+'还有我的妻子' console.log(b); let b1 = `我爱我的祖国$&#123;a&#125;还有我的妻子` console.log(b1); 调用函数// 调用函数 function fn()&#123; return '祖国' &#125; console.log(`亲爱的$&#123;fn()&#125;你好`); 模板字符串嵌套// 支持嵌套 let arr = [1,2,3] const str = (arr)=&gt;` 我是一级字符串 $&#123;arr.map(v=&gt;`$&#123;v&#125;`)&#125; ` console.log(str(arr)); 注意点`\\`` 新增的实例方法includes() startsWith() endsWith()// includes()返回布尔值 startsWith() endsWith() let s = 'hello world' console.log(s.includes('o')); console.log(s.includes('p')); console.log(s.startsWith('hello')); console.log(s.endsWith('world')); // 支持第二个参数 表示开始搜索的位置 从o0开始的 console.log( s.startsWith('world',6)); console.log( s.startsWith('world',7)); repeat()// repeat() console.log('x'.repeat(3)); console.log('hello'.repeat(3)); padStart() padEnd()console.log('x'.padStart(5,'ab')); // 总得长度 从开始位置填充的东西 // 提示字符串的格式console.log('17'.padStart(10,'YYYY-MM-DD'));console.log('12-06'.padStart(10,'YYYY-MM-DD')); 数组的扩展方法展开运算符 … 拆包函数调用的体现function f(a,b,c)&#123; console.log(a); console.log(b); console.log(c); &#125; var args = [1,2,3] // f.apply(null,args) // 拆包 // console.log(...args); f(...args) 后面可以放表达式let a = 1; const arr = [ ...(a&gt;0? ['a']: []) ] console.log(arr); 替代函数的apply方法// 思考连接两个数组的方法 let arr1 = [1,2,3] let arr2 = [4,5,6] console.log(arr1.concat(arr2)); console.log(arr1); // ? 想让原来的数组改变 // es5的想到的话 你的基本功也很扎实 // es5 解决办法 Array.prototype.push.apply(arr1,arr2); console.log(arr1); // es6 // (...arr1) += (...arr2) // 扩展运算符只有函数调用的时候才可以放在圆括号当中 // (...[1,2]) // console.log((...[1,2])); arr1.push(...arr2); console.log(arr1); 复制数组const a1 = [1,2]const a2 = a1;// 复制console.log(a1 === a2);// 指向同一个房间// a2[0] = 2// console.log(a1);// 是不是浅克隆？这不是浅克隆 这叫复制// 浅克隆是长得一样 但是地址不一样const a3 = a1.concat()// 浅拷贝console.log(a3);console.log(a1 === a3);// 没有指向同一个房间 const a4 = [...a1]console.log(a4);console.log(a4 === a1);// 浅拷贝// 展开运算符是浅拷贝 而不是 深拷贝let arr = [&#123;a:1&#125;,2,3]// let arr1 = [...arr] // 是深拷贝嘛？// arr1[0].a = 2// // 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝// console.log(arr); // // 深拷贝 除了递归能实现let arr2 = JSON.parse(JSON.stringify(arr))arr2[0].a = 2;// 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝console.log(arr); …打包// const [first,...arr] = [1,2,3,4,5] // console.log(arr); // const [o,...s] = []; // console.log(o) // undefined // console.log(s) // [] // 只能放在参数的最后一位 // const [...arr,first] = [1,2,3,4,5] Array.from()// Array.from() 用于把类数组对象转化成真正的数组 // 部署了 iterator 接口 都可以用Array.from()转化成真正的数组 // 有 length属性 没有数组操作的一些方法 push function get(a,b,c)&#123; console.log(arguments); console.log(Array.from(arguments)); &#125; get(1,2,3) const copyArr = &#123; '0':'a', '1':'b', length:2 &#125; console.log(Array.from(copyArr)); Array.of()// 可以将一组值转化成数组 console.log(Array.of(2,3,4,5)); // ？ 弥补数组构造函数的一些不足 console.log(Array(3).length); // 当参数不少于2个时候 console.log(Array(1,2,3)); console.log(Array.of(3)); copyWithin()// copyWithin() // 1 必须要传的 从该位置开始替换数据 // 2 start 从该位置读取数据 默认是0 // 3 end console.log([1,2,3,4,5].copyWithin(0,3)); // [4,5,3,4,5] find() findIndex()let arr = [1,2,3,-1,-2,45] let res = arr.find(function(i)&#123; return i&lt;0 &#125;) console.log(res); let resIndex = arr.findIndex(function(i)&#123; return i&lt;0 &#125;) console.log(resIndex) 作业分别用 includes() find() findIndex()实现数组的去重 let arr = [1,2,3,4,1,3,5,7,89,45,23,1]","comments":true,"tags":[]},{"title":"es6-块级作用域 解构赋值","date":"2019-12-06T03:10:53.000Z","path":"2019/12/06/es6/es6块级作用域解构赋值/","text":"1. es6的背景介绍ES6是什么？ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了和js之间的关系ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。作用是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。（更具模块化） 2. let const var2.1. 不存在变量提升// es5// 1 全程扫描一下错误 2 预编译环节console.log(a); // undefinedvar a = 123// es6 console.log(b);let b = 456;console.log(b); 2.2. 暂时性死区2.2.1. let死区var tep = 890;if(true)&#123; tep = 'abc' let tep&#125; 2.2.2. typeof 不再是百分百报错// typeof 不再是完全正确的console.log(typeof c);let c; 2.2.3. 不允许重复声明let e = 123;let e = 456// 'e' has already been declared 2.3. 块级作用域2.3.1. 为什么要有块级作用域？ // 内层的变量会覆盖外层的变量var a = '全局'function fn()&#123; // 预编译 找var a // var a console.log(a); // undefined if(false)&#123; var a = '局部' &#125;&#125;fn()// 复习预编译的东西// 全局 函数作用 块级作用域（在各自的块干自己的事情 不影响）var a = '全局';(function()&#123; var a = '局部' console.log(a); &#125;())console.log(a) let a = '全局'&#123; let a = '局部' console.log(a);&#125;console.log(a); 2.3.2. 允许作用域的任意嵌套// 允许作用域的任意嵌套&#123; &#123; let b = '局部' &#125; console.log(b); // b is not defined&#125;&#123; &#123; let b = '局部' &#123; console.log(b); &#125; &#125;&#125; 2.3.3. 注意if(true)&#123; let x = 1;&#125; // 不会报错if(true) let y = 2 // 会报错// Lexical declaration cannot appear in a single-statement context 2.3.4. 开发中具体的例子2.4. const 特殊的地方2.4.1. 声明常量不能变const a = 123;a = '123'const b = true;b = false 2.4.2. 本质// 引用数据类型可以变变得是堆里面的内容 不变的是地址const obj = &#123;name:'chris',age:33&#125; console.log(obj);obj = &#123;name:'Chris',age:33&#125; 2.4.3. 可以冻结对象// const foo = Object.freeze(&#123;&#125;)// foo.name = '大白菜'// console.log(foo);'use strict'const foo = Object.freeze(&#123;&#125;)foo.name = '大白菜' 2.5. 全局的缺陷 // new Array()console.log(window.Array);var Array = '这是数组'console.log(window.Array);var a = '123'console.log(window.a); // 123let b = '全局'console.log(window.b); // undefined// let 提出后 全局变量和顶层对象的属性 脱钩 3. 解构赋值3.1. 数组解构赋值// 通过数组对变量进行赋值let arr = [1,2,3]console.log(arr[0]);console.log(arr[1]);console.log(arr[2]);let [a,b,c] = [1,2,3]console.log(a);console.log(b);console.log(c); 3.1.1. 模式匹配等号两边的模式相同 左边的变量就会被赋予对应的值 let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.2. 不完全解构// 不完全解构 let [x,y,u] = [1,2,3,4] console.log(x); console.log(y); console.log(u); 3.1.3. 嵌套模式let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.4. 默认值// 指定默认值 let [f = true] = [] console.log(f); let [a,b=\"y\"] = ['a'] console.log(b); // 注意点 es6内部使用 === 判断是否是undefined 如果是undefined 默认值才会生效 let [x = 1] = [null] let [y = 2] = [undefined] console.log(x); // null console.log(y); // 2 3.1.4.1. 惰性求值// 惰性求值 function f()&#123; return 'fff' &#125; // let [x = f()] = [1] let [x = f()] = [] console.log(x); 3.1.4.2. 默认值可以引用解构赋值的其他变量// 默认值可以引用解构赋值的其它变量 前提是变量必须已经声明 // let [x= 1,y=x] = [] // console.log(x); // 1 // console.log(y); // let [x = y,y=1] = [] // 从左往右 // let [y = 1 , x = y] = [] // console.log(x); // console.log(y); 3.2. 对象解构赋值3.2.1. 定义用法注意点let person = &#123; name:\"chris\", age:33 &#125; // let &#123;name,age&#125; = person; // 注意：对象的解构和数组不一样 和顺序无关 let &#123;age:age,name:name&#125; = person; console.log(name); console.log(age); let &#123;sex&#125; = person; console.log(sex); // 解构不成功会返回undefined // 真正被赋值的是后者 对象解构赋值的实质 // 会先找到同名的属性 赋值给后者的变量 let &#123;name:name1&#125; = person console.log(name1); 3.2.2. 可以取到继承的属性const obj1 = &#123;&#125;;const obj2 = &#123;name:'laney'&#125;Object.setPrototypeOf(obj1,obj2)// obj1.__proto__ = obj2const &#123;name&#125; = obj1;console.log(name); 3.2.3. 指定默认值// 默认值的生效条件 对象属性的值 严格 === undefinedconst &#123;x = 1&#125; = &#123;x:undefined&#125;const &#123;y = 3&#125; = &#123;y:null&#125;console.log(x);console.log(y); 作业// 作业题 const items = [ ['name','张飞'], ['title','长坂坡一声吼'] ] // 循环数组 分别打印 第二层数组的值 用数组的解构来做","comments":true,"tags":[]},{"title":"数组去重","date":"2019-12-06T03:10:53.000Z","path":"2019/12/06/面试题/js面试题/","text":"let arr = [1,2,3,4,1,3,5,7,89,45,23,1]function uniqueOne(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; var array =[]; for(var i = 0; i &lt; arr.length; i++) &#123; if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值 array.push(arr[i]); &#125; &#125; return array&#125;console.log(uniqueOne(arr))function uniqueTwo(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if(!arrs.find((v)=&gt;&#123; return v==array[i] &#125;))&#123; arrs.push(array[i]) &#125; &#125; return arrs; &#125;console.log(uniqueTwo(arr))function uniqueThree(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if (arrs.indexOf(array[i]) == -1)&#123; arrs.push(array[i]) &#125;; &#125; return arrs; &#125; console.log(uniqueThree(arr))function uniqueFour(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if(arrs.findIndex((v)=&gt;&#123; return v == array[i] &#125;)==-1)&#123; arrs.push(array[i]) &#125; // if(arrs.findIndex(function(v)&#123; // return v == array[i] // &#125;)==-1)&#123; // arrs.push(array[i]) // &#125; &#125; return arrs; &#125;console.log(uniqueFour(arr))","comments":true,"tags":[]},{"title":"ts的基本数据类型","date":"2019-12-03T01:50:26.681Z","path":"2019/12/03/ts/ts基本数据类型/","text":"布尔数据类型/** * typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验， * 在typescript中主要给我们提供了以下数据类型 布尔类型（boolean） 数字类型（number） 字符串类型(string) 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 */// 布尔类型var flag:boolean = true;flag = false;// flag = 124 // 错误写法console.log(flag);// 数字类型var num:number = 123;num = 456;console.log(num); // num = 'str' // 错误写法// 字符串数据类型var str:string = 'this is ts'str = 'haha'// str = true // 错误console.log(str);// 定义数组的三种方式(数组类型)// 第一种var arr:number[] = [11,22,33]console.log(arr);// 第二种 元祖类型 属于数组的一种var arr2:Array&lt;number&gt; = [1,2,3]console.log(arr2);// var arr22:Array&lt;string&gt; = [1,2,'12'] // 错误写法// 第三种 通过anyvar arr3:any[] = [[123],123,'str']console.log(arr3);/* 枚举类型（enum） 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值， 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数], &#125;; */enum Flag &#123;success = 1,error=2&#125;;let s:Flag = Flag.success;let f:Flag = Flag.errorconsole.log(s); // 1console.log(f); // 2// 如果标识符没有赋值 它的值就是下标enum Color &#123;blue, red, 'orange'&#125;var c:Color = Color.red;console.log(c); // 1enum Car &#123;bmw,honda,jeep=3,toyota&#125;var j:Car = Car.jeepconsole.log(j); // 3var t:Car = Car.toyota;console.log(t); // 4enum Err &#123;'undefined' = -1,'null'= -2,'success'=1&#125;var e:Err = Err.success;console.log(e); // 1// 任意类型var ares:any = 123;ares = '123'ares = trueares = undefined;ares = 'any'console.log(ares);// 任意数据类型的用处var oBox:any=document.getElementById('box');oBox.style.width = '100px'oBox.style.height = '200px'oBox.style.background='red';// undefined 和 null // var unum:number;// console.log(unum); // 错误// var unum:undefined;// console.log(unum); // 正确// var unum:number | undefined;// unum = 123;// console.log(unum);// 没有赋值就是undefinedvar unum:number | undefined;console.log(unum); // undefined// null 类型var unull:null;unull = nullconsole.log(unull);// 一个元素可能是number类型 可能是null 可能是undefinedvar unumll:number | null | undefined;unumll = 1234;console.log(unumll);// void类型: typescript中的void表示没有任何类型 一般用于定义方法的时候没有返回值// es5的定义方法// function run()&#123;// console.log('run'); // &#125;// run()// ts中的写法 // function run():void&#123;// console.log('run'); // &#125;// run()// 错误的写法// function run():undefined&#123;// console.log('run'); // &#125;// A function whose declared type is neither 'void' nor 'any' must return a value.// 声明类型既不是“ void”也不是“ any”的函数必须返回一个值。// 正确的写法function returnnum():number&#123; return 124&#125;console.log(returnnum());// never类型:代表从不会出现的值。//这意味着声明never的变量只能被never类型所赋值。var a:never;// a=123; //错误的写法a=(()=&gt;&#123; throw new Error('错误');&#125;)()","comments":true,"tags":[]},{"title":"js的数据属性和访问器属性","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js高级进阶/js对象的数据属性和访问器属性/","text":"何为属性？属性就是与对象相关的值，而数据属性和访问器属性，就是属性的属性，用于描述属性的行为特性。 数据属性数据属性（property）用于实现JavaScript引擎，是属性(property)的内部值，它包含一个数据值的位置。有如下4种行为特性。[[Configurable]]：能否被delete删除属性重新定义[[Enumerable]]：能否被for-in枚举[[Writable]]：能否修改属性值[[Value]]：数据的数据值 // 一个名叫huahua的狗狗var dog = &#123;name: 'Obama'&#125; 此处有一个名为name的属性，其值是‘Obama’，即[[Value]]的值就是‘Obama’，任何修改name属性的操作，都能在[[value]]上显示出来。通过Object.getOwnPropertyDescriptor()方法，我们可以查看属性name的默认数据属性。Object.getOwnPropertyDescriptor(dog, ‘name’)那么，如何修改默认属性的值呢？使用Object.defineProperty()可以修改默认属性。包含三个参数：属性所在对象，属性名称，描述符对象。 // 将狗狗的名字改成川普Object.defineProperty(dog, 'name', &#123; writable: false, value: 'Trump'&#125;) 由于修改了默认属性name的描述符对象writable的值为false，故无法修改属性值。其他描述符类似。 访问器属性访问器属性主要由setter和getter函数组成，包含如下4个特性：[[Configurable]]：能否被delete删除属性重新定义。默认值：true[[Enumerable]]：能否被for-in枚举。默认值：true[[Get]]：读取属性值。默认值：undefined[[Set]]：写入属性值。默认值：undefined var dog = &#123; _age: 2, weight: 10&#125;Object.defineProperty(dog, 'age', &#123; get: function () &#123; return this._age &#125;, set: function (newVal) &#123; this._age = newVal this.weight += 1 &#125;&#125;) _age属性前面的下划线是一种常用的记号，是一种只能通过对象方法访问的属性。 小结： Object.defineProperty()方法可以为全局对象定义属性，该全局对象的所有实例，都可使用该属性 set方法可以监听对象属性值得变化，如此，双向数据绑定就能够使用js实现了。","comments":true,"tags":[]},{"title":"js闭包的理解","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js高级进阶/js闭包的理解/","text":"形成闭包: 函数里面套函数，内部的函数被保存到了外部，形成闭包 特点： 内部函数可以引用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 缺点： 常驻内存增加内存使用量 使用不当很容易造成内存泄露 优点： 避免全局变量的污染 var a = 123;var get = (function()&#123; var a = 345; function getAo()&#123; console.log(a) &#125; return function()&#123; getAo() &#125;&#125;())get() 实现私有变量 function Person(name)&#123; // 定义一个私有变量 这里的意思是私房钱 var privateMoney = 20000; this.name = name; this.getPrivate = function()&#123; this.ownMoney = privateMoney &#125; this.changePrivate = function(target)&#123; privateMoney = target+privateMoney; &#125;&#125;let chris = new Person('Chris')// 看看自己有多少私房钱chris.getPrivate()console.log(chris.ownMoney)// 这里之所以可以看到是因为用到了闭包// 此时可以继续存储私房钱 chris.changePrivate(40000);chris.getPrivate()console.log(chris.ownMoney) // 此时私房钱就变成了60000// 但是我们直接去访问chris.privateMoney 是访问不到的console.log(chris,privateMoney)// 此时会报错 实现私有变量 他自己可以内部用但是我们外部访问不到 可以保存一个变量长期储存在内存中 function fn()&#123; var arr = []; for(var i= 0;i&lt;=9;i++)&#123; arr[j] = function()&#123; console.log(j) &#125; &#125; return arr;&#125;var resArr = fn();resArr[1]() // 10 resArr[2]() // 10","comments":true,"tags":[]}]
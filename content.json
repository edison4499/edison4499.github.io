[{"title":"ts基本数据类型","date":"2019-12-03T01:50:26.681Z","path":"2019/12/03/ts基本数据类型/","text":"布尔数据类型1/**2 * typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验，3 * 在typescript中主要给我们提供了以下数据类型4 布尔类型（boolean）5 数字类型（number）6 字符串类型(string)7 数组类型（array）8 元组类型（tuple）9 枚举类型（enum）10 任意类型（any）11 null 和 undefined12 void类型13 never类型14 */15// 布尔类型16var flag:boolean = true;17flag = false;18// flag = 124 // 错误写法19console.log(flag);2021// 数字类型22var num:number = 123;23num = 456;24console.log(num); 25// num = 'str' // 错误写法2627// 字符串数据类型28var str:string = 'this is ts'29str = 'haha'30// str = true // 错误31console.log(str);3233// 定义数组的三种方式(数组类型)34// 第一种35var arr:number[] = [11,22,33]36console.log(arr);37// 第二种 元祖类型 属于数组的一种38var arr2:Array&lt;number&gt; = [1,2,3]39console.log(arr2);40// var arr22:Array&lt;string&gt; = [1,2,'12'] // 错误写法41// 第三种 通过any42var arr3:any[] = [[123],123,'str']43console.log(arr3);4445/*46 枚举类型（enum）47 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。48 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 49 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。50 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。51 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值，52 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 53 enum 枚举名&#123; 54 标识符[=整型常数], 55 标识符[=整型常数], 56 ... 57 标识符[=整型常数], 58 &#125;; 59 */6061enum Flag &#123;success = 1,error=2&#125;;62let s:Flag = Flag.success;63let f:Flag = Flag.error64console.log(s); // 165console.log(f); // 26667// 如果标识符没有赋值 它的值就是下标6869enum Color &#123;blue, red, 'orange'&#125;70var c:Color = Color.red;71console.log(c); // 17273enum Car &#123;bmw,honda,jeep=3,toyota&#125;74var j:Car = Car.jeep75console.log(j); // 376var t:Car = Car.toyota;77console.log(t); // 47879enum Err &#123;'undefined' = -1,'null'= -2,'success'=1&#125;80var e:Err = Err.success;81console.log(e); // 18283// 任意类型8485var ares:any = 123;86ares = '123'87ares = true88ares = undefined;89ares = 'any'90console.log(ares);91// 任意数据类型的用处9293var oBox:any=document.getElementById('box');94oBox.style.width = '100px'95oBox.style.height = '200px'96oBox.style.background='red';9798// undefined 和 null 99100// var unum:number;101// console.log(unum); // 错误102// var unum:undefined;103// console.log(unum); // 正确104105// var unum:number | undefined;106// unum = 123;107// console.log(unum);108109// 没有赋值就是undefined110var unum:number | undefined;111console.log(unum); // undefined112113// null 类型114var unull:null;115unull = null116console.log(unull);117118// 一个元素可能是number类型 可能是null 可能是undefined119120var unumll:number | null | undefined;121unumll = 1234;122console.log(unumll);123124// void类型: typescript中的void表示没有任何类型 一般用于定义方法的时候没有返回值125126// es5的定义方法127// function run()&#123;128// console.log('run');129 130// &#125;131// run()132133// ts中的写法 134// function run():void&#123;135// console.log('run');136 137// &#125;138// run()139// 错误的写法140// function run():undefined&#123;141// console.log('run');142 143// &#125;144// A function whose declared type is neither 'void' nor 'any' must return a value.145// 声明类型既不是“ void”也不是“ any”的函数必须返回一个值。146147// 正确的写法148149function returnnum():number&#123;150 return 124151&#125;152console.log(returnnum());153154// never类型:代表从不会出现的值。155156//这意味着声明never的变量只能被never类型所赋值。157var a:never;158159// a=123; //错误的写法160a=(()=&gt;&#123;161 throw new Error('错误');162&#125;)()","comments":true,"tags":[]},{"title":"js闭包的理解","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js闭包理解/","text":"形成闭包: 函数里面套函数，内部的函数被保存到了外部，形成闭包 特点： 内部函数可以引用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 缺点： 常驻内存增加内存使用量 使用不当很容易造成内存泄露 优点： 避免全局变量的污染1var a = 123;2var get = (function()&#123;3 var a = 345;4 function getAo()&#123;5 console.log(a)6 &#125;7 return function()&#123;8 getAo()9 &#125;10&#125;())11get() 实现私有变量1function Person(name)&#123;2 // 定义一个私有变量 这里的意思是私房钱3 var privateMoney = 20000;4 this.name = name;5 this.getPrivate = function()&#123;6 this.ownMoney = privateMoney7 &#125;8 this.changePrivate = function(target)&#123;9 privateMoney = target+privateMoney;10 &#125;11&#125;12let chris = new Person('Chris')13// 看看自己有多少私房钱14chris.getPrivate()15console.log(chris.ownMoney)// 这里之所以可以看到是因为用到了闭包16// 此时可以继续存储私房钱 17chris.changePrivate(40000);18chris.getPrivate()19console.log(chris.ownMoney) // 此时私房钱就变成了6000020// 但是我们直接去访问chris.privateMoney 是访问不到的21console.log(chris,privateMoney)// 此时会报错 实现私有变量 他自己可以内部用但是我们外部访问不到 可以保存一个变量长期储存在内存中1function fn()&#123;2 var arr = [];3 for(var i= 0;i&lt;=9;i++)&#123;4 arr[j] = function()&#123;5 console.log(j)6 &#125;7 &#125;8 return arr;9&#125;10var resArr = fn();11resArr[1]() // 10 12resArr[2]() // 10","comments":true,"tags":[]}]
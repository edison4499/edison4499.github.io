[{"title":"es6字符串数组的扩展方法","date":"2019-12-07T05:05:53.000Z","path":"2019/12/07/字符串数组的扩展/","text":"字符串的扩展方法模板字符串简便换行和嵌入变量操作// 简便换行 let s1 = '我爱我的祖国\\n和我的母亲' console.log(s1); let s2 = `我爱我的祖国和我的母亲` console.log(s2); let a = '和我的母亲' let b = '我爱我的祖国'+a+'还有我的妻子' console.log(b); let b1 = `我爱我的祖国$&#123;a&#125;还有我的妻子` console.log(b1); 调用函数// 调用函数 function fn()&#123; return '祖国' &#125; console.log(`亲爱的$&#123;fn()&#125;你好`); 模板字符串嵌套// 支持嵌套 let arr = [1,2,3] const str = (arr)=&gt;` 我是一级字符串 $&#123;arr.map(v=&gt;`$&#123;v&#125;`)&#125; ` console.log(str(arr)); 注意点`\\`` 新增的实例方法includes() startsWith() endsWith()// includes()返回布尔值 startsWith() endsWith() let s = 'hello world' console.log(s.includes('o')); console.log(s.includes('p')); console.log(s.startsWith('hello')); console.log(s.endsWith('world')); // 支持第二个参数 表示开始搜索的位置 从o0开始的 console.log( s.startsWith('world',6)); console.log( s.startsWith('world',7)); repeat()// repeat() console.log('x'.repeat(3)); console.log('hello'.repeat(3)); padStart() padEnd()console.log('x'.padStart(5,'ab')); // 总得长度 从开始位置填充的东西 // 提示字符串的格式console.log('17'.padStart(10,'YYYY-MM-DD'));console.log('12-06'.padStart(10,'YYYY-MM-DD')); 数组的扩展方法展开运算符 … 拆包函数调用的体现function f(a,b,c)&#123; console.log(a); console.log(b); console.log(c); &#125; var args = [1,2,3] // f.apply(null,args) // 拆包 // console.log(...args); f(...args) 后面可以放表达式let a = 1; const arr = [ ...(a&gt;0? ['a']: []) ] console.log(arr); 替代函数的apply方法// 思考连接两个数组的方法 let arr1 = [1,2,3] let arr2 = [4,5,6] console.log(arr1.concat(arr2)); console.log(arr1); // ? 想让原来的数组改变 // es5的想到的话 你的基本功也很扎实 // es5 解决办法 Array.prototype.push.apply(arr1,arr2); console.log(arr1); // es6 // (...arr1) += (...arr2) // 扩展运算符只有函数调用的时候才可以放在圆括号当中 // (...[1,2]) // console.log((...[1,2])); arr1.push(...arr2); console.log(arr1); 复制数组const a1 = [1,2]const a2 = a1;// 复制console.log(a1 === a2);// 指向同一个房间// a2[0] = 2// console.log(a1);// 是不是浅克隆？这不是浅克隆 这叫复制// 浅克隆是长得一样 但是地址不一样const a3 = a1.concat()// 浅拷贝console.log(a3);console.log(a1 === a3);// 没有指向同一个房间 const a4 = [...a1]console.log(a4);console.log(a4 === a1);// 浅拷贝// 展开运算符是浅拷贝 而不是 深拷贝let arr = [&#123;a:1&#125;,2,3]// let arr1 = [...arr] // 是深拷贝嘛？// arr1[0].a = 2// // 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝// console.log(arr); // // 深拷贝 除了递归能实现let arr2 = JSON.parse(JSON.stringify(arr))arr2[0].a = 2;// 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝console.log(arr); …打包// const [first,...arr] = [1,2,3,4,5] // console.log(arr); // const [o,...s] = []; // console.log(o) // undefined // console.log(s) // [] // 只能放在参数的最后一位 // const [...arr,first] = [1,2,3,4,5] Array.from()// Array.from() 用于把类数组对象转化成真正的数组 // 部署了 iterator 接口 都可以用Array.from()转化成真正的数组 // 有 length属性 没有数组操作的一些方法 push function get(a,b,c)&#123; console.log(arguments); console.log(Array.from(arguments)); &#125; get(1,2,3) const copyArr = &#123; '0':'a', '1':'b', length:2 &#125; console.log(Array.from(copyArr)); Array.of()// 可以将一组值转化成数组 console.log(Array.of(2,3,4,5)); // ？ 弥补数组构造函数的一些不足 console.log(Array(3).length); // 当参数不少于2个时候 console.log(Array(1,2,3)); console.log(Array.of(3)); copyWithin()// copyWithin() // 1 必须要传的 从该位置开始替换数据 // 2 start 从该位置读取数据 默认是0 // 3 end console.log([1,2,3,4,5].copyWithin(0,3)); // [4,5,3,4,5] find() findIndex()let arr = [1,2,3,-1,-2,45] let res = arr.find(function(i)&#123; return i&lt;0 &#125;) console.log(res); let resIndex = arr.findIndex(function(i)&#123; return i&lt;0 &#125;) console.log(resIndex) 作业分别用 includes() find() findIndex()实现数组的去重 let arr = [1,2,3,4,1,3,5,7,89,45,23,1]","comments":true,"tags":[]},{"title":"es6块级作用域 解构赋值","date":"2019-12-06T03:10:53.000Z","path":"2019/12/06/es6/","text":"1. es6的背景介绍ES6是什么？ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了和js之间的关系ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。作用是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。（更具模块化） 2. let const var2.1. 不存在变量提升// es5// 1 全程扫描一下错误 2 预编译环节console.log(a); // undefinedvar a = 123// es6 console.log(b);let b = 456;console.log(b); 2.2. 暂时性死区2.2.1. let死区var tep = 890;if(true)&#123; tep = 'abc' let tep&#125; 2.2.2. typeof 不再是百分百报错// typeof 不再是完全正确的console.log(typeof c);let c; 2.2.3. 不允许重复声明let e = 123;let e = 456// 'e' has already been declared 2.3. 块级作用域2.3.1. 为什么要有块级作用域？ // 内层的变量会覆盖外层的变量var a = '全局'function fn()&#123; // 预编译 找var a // var a console.log(a); // undefined if(false)&#123; var a = '局部' &#125;&#125;fn()// 复习预编译的东西// 全局 函数作用 块级作用域（在各自的块干自己的事情 不影响）var a = '全局';(function()&#123; var a = '局部' console.log(a); &#125;())console.log(a) let a = '全局'&#123; let a = '局部' console.log(a);&#125;console.log(a); 2.3.2. 允许作用域的任意嵌套// 允许作用域的任意嵌套&#123; &#123; let b = '局部' &#125; console.log(b); // b is not defined&#125;&#123; &#123; let b = '局部' &#123; console.log(b); &#125; &#125;&#125; 2.3.3. 注意if(true)&#123; let x = 1;&#125; // 不会报错if(true) let y = 2 // 会报错// Lexical declaration cannot appear in a single-statement context 2.3.4. 开发中具体的例子2.4. const 特殊的地方2.4.1. 声明常量不能变const a = 123;a = '123'const b = true;b = false 2.4.2. 本质// 引用数据类型可以变变得是堆里面的内容 不变的是地址const obj = &#123;name:'chris',age:33&#125; console.log(obj);obj = &#123;name:'Chris',age:33&#125; 2.4.3. 可以冻结对象// const foo = Object.freeze(&#123;&#125;)// foo.name = '大白菜'// console.log(foo);'use strict'const foo = Object.freeze(&#123;&#125;)foo.name = '大白菜' 2.5. 全局的缺陷 // new Array()console.log(window.Array);var Array = '这是数组'console.log(window.Array);var a = '123'console.log(window.a); // 123let b = '全局'console.log(window.b); // undefined// let 提出后 全局变量和顶层对象的属性 脱钩 3. 解构赋值3.1. 数组解构赋值// 通过数组对变量进行赋值let arr = [1,2,3]console.log(arr[0]);console.log(arr[1]);console.log(arr[2]);let [a,b,c] = [1,2,3]console.log(a);console.log(b);console.log(c); 3.1.1. 模式匹配等号两边的模式相同 左边的变量就会被赋予对应的值 let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.2. 不完全解构// 不完全解构 let [x,y,u] = [1,2,3,4] console.log(x); console.log(y); console.log(u); 3.1.3. 嵌套模式let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.4. 默认值// 指定默认值 let [f = true] = [] console.log(f); let [a,b=\"y\"] = ['a'] console.log(b); // 注意点 es6内部使用 === 判断是否是undefined 如果是undefined 默认值才会生效 let [x = 1] = [null] let [y = 2] = [undefined] console.log(x); // null console.log(y); // 2 3.1.4.1. 惰性求值// 惰性求值 function f()&#123; return 'fff' &#125; // let [x = f()] = [1] let [x = f()] = [] console.log(x); 3.1.4.2. 默认值可以引用解构赋值的其他变量// 默认值可以引用解构赋值的其它变量 前提是变量必须已经声明 // let [x= 1,y=x] = [] // console.log(x); // 1 // console.log(y); // let [x = y,y=1] = [] // 从左往右 // let [y = 1 , x = y] = [] // console.log(x); // console.log(y); 3.2. 对象解构赋值3.2.1. 定义用法注意点let person = &#123; name:\"chris\", age:33 &#125; // let &#123;name,age&#125; = person; // 注意：对象的解构和数组不一样 和顺序无关 let &#123;age:age,name:name&#125; = person; console.log(name); console.log(age); let &#123;sex&#125; = person; console.log(sex); // 解构不成功会返回undefined // 真正被赋值的是后者 对象解构赋值的实质 // 会先找到同名的属性 赋值给后者的变量 let &#123;name:name1&#125; = person console.log(name1); 3.2.2. 可以取到继承的属性const obj1 = &#123;&#125;;const obj2 = &#123;name:'laney'&#125;Object.setPrototypeOf(obj1,obj2)// obj1.__proto__ = obj2const &#123;name&#125; = obj1;console.log(name); 3.2.3. 指定默认值// 默认值的生效条件 对象属性的值 严格 === undefinedconst &#123;x = 1&#125; = &#123;x:undefined&#125;const &#123;y = 3&#125; = &#123;y:null&#125;console.log(x);console.log(y); 作业// 作业题 const items = [ ['name','张飞'], ['title','长坂坡一声吼'] ] // 循环数组 分别打印 第二层数组的值 用数组的解构来做","comments":true,"tags":[]},{"title":"splitChunks的配置详解","date":"2019-12-04T08:12:51.233Z","path":"2019/12/04/splitChunks的配置详解/","text":"optimization:&#123; splitChunks:&#123; chunks: 'all', // all 所有 async 异步 initial 同步 minSize: 30000,// 最小的字节大小这里是30kb // maxSize: 0,// 最大的 这一项一般不用 意思是假设打包的有1mb 这里设置500000 // 会尝试进行二次的拆分 minChunks: 1, // 引入的块的最小值 比如说这里只引入了lodash如果这里改成2的话 就不会做代码分割了 maxAsyncRequests: 6,// 最大的代码分割数 比如说你引入了7个 但是这里设置6 只会对前6个做分割 maxInitialRequests: 4,// 整个网站首页加载的时候的最大引入数 automaticNameDelimiter: '~', // 打包后文件名字的连接符号 automaticNameMaxLength: 30, // 设置块名称的最大字符 name:true, // 指的是下面的filename的名字生效 cacheGroups: &#123; // 缓存组 代码分割后的非业务逻辑代码打包到一起 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, //检测是否在node_modules目录 priority: -20, // 这个是优先级和下面default的priority做对比 // 引入的lodash符合在nodemodules下面 // filename:'[name].bundle.js' name:'vendor' &#125;, default: &#123;// 检测的是没有在node_modules 目录下的时候的处理 minChunks: 2,// 引入块的最小值 priority: -10,// 优先级 // 引入的lodash也符合在default 所有的模块都符合 此时就是比较权重了 // 注意哪怕这里的权重比上面的高 但是被上面的test匹配到了之后还是会走上面的 reuseExistingChunk: true, // 比如说有两个模块 a 和 b a里面引入的有b // 正常来说打包a的话会把b也打包进去 // 但是假如说以前b已经被打包过了 那么就不会再次被打包进去了 name:'common' &#125; &#125; &#125;&#125;","comments":true,"tags":[]},{"title":"webpack-codeSpliting","date":"2019-12-03T09:23:29.138Z","path":"2019/12/03/webpack-codeSpliting/","text":"好比说项目中引入了lodashlodash 和 我们的逻辑代码就可以做一个分割 优点每次加载的文件的大小基本没变 只不过分两次加载但是由于浏览器有缓存的原因 比如第三方的lodash分开加载的话由于浏览器缓存的原因没有做改变的话是不会重新加载的这样一来就增加了开发效率 在webpack中的配置截图如下","comments":true,"tags":[]},{"title":"ts基本数据类型","date":"2019-12-03T01:50:26.681Z","path":"2019/12/03/ts基本数据类型/","text":"布尔数据类型/** * typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验， * 在typescript中主要给我们提供了以下数据类型 布尔类型（boolean） 数字类型（number） 字符串类型(string) 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 */// 布尔类型var flag:boolean = true;flag = false;// flag = 124 // 错误写法console.log(flag);// 数字类型var num:number = 123;num = 456;console.log(num); // num = 'str' // 错误写法// 字符串数据类型var str:string = 'this is ts'str = 'haha'// str = true // 错误console.log(str);// 定义数组的三种方式(数组类型)// 第一种var arr:number[] = [11,22,33]console.log(arr);// 第二种 元祖类型 属于数组的一种var arr2:Array&lt;number&gt; = [1,2,3]console.log(arr2);// var arr22:Array&lt;string&gt; = [1,2,'12'] // 错误写法// 第三种 通过anyvar arr3:any[] = [[123],123,'str']console.log(arr3);/* 枚举类型（enum） 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值， 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数], &#125;; */enum Flag &#123;success = 1,error=2&#125;;let s:Flag = Flag.success;let f:Flag = Flag.errorconsole.log(s); // 1console.log(f); // 2// 如果标识符没有赋值 它的值就是下标enum Color &#123;blue, red, 'orange'&#125;var c:Color = Color.red;console.log(c); // 1enum Car &#123;bmw,honda,jeep=3,toyota&#125;var j:Car = Car.jeepconsole.log(j); // 3var t:Car = Car.toyota;console.log(t); // 4enum Err &#123;'undefined' = -1,'null'= -2,'success'=1&#125;var e:Err = Err.success;console.log(e); // 1// 任意类型var ares:any = 123;ares = '123'ares = trueares = undefined;ares = 'any'console.log(ares);// 任意数据类型的用处var oBox:any=document.getElementById('box');oBox.style.width = '100px'oBox.style.height = '200px'oBox.style.background='red';// undefined 和 null // var unum:number;// console.log(unum); // 错误// var unum:undefined;// console.log(unum); // 正确// var unum:number | undefined;// unum = 123;// console.log(unum);// 没有赋值就是undefinedvar unum:number | undefined;console.log(unum); // undefined// null 类型var unull:null;unull = nullconsole.log(unull);// 一个元素可能是number类型 可能是null 可能是undefinedvar unumll:number | null | undefined;unumll = 1234;console.log(unumll);// void类型: typescript中的void表示没有任何类型 一般用于定义方法的时候没有返回值// es5的定义方法// function run()&#123;// console.log('run'); // &#125;// run()// ts中的写法 // function run():void&#123;// console.log('run'); // &#125;// run()// 错误的写法// function run():undefined&#123;// console.log('run'); // &#125;// A function whose declared type is neither 'void' nor 'any' must return a value.// 声明类型既不是“ void”也不是“ any”的函数必须返回一个值。// 正确的写法function returnnum():number&#123; return 124&#125;console.log(returnnum());// never类型:代表从不会出现的值。//这意味着声明never的变量只能被never类型所赋值。var a:never;// a=123; //错误的写法a=(()=&gt;&#123; throw new Error('错误');&#125;)()","comments":true,"tags":[]},{"title":"js闭包的理解","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js闭包的理解/","text":"形成闭包: 函数里面套函数，内部的函数被保存到了外部，形成闭包 特点： 内部函数可以引用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 缺点： 常驻内存增加内存使用量 使用不当很容易造成内存泄露 优点： 避免全局变量的污染var a = 123;var get = (function()&#123; var a = 345; function getAo()&#123; console.log(a) &#125; return function()&#123; getAo() &#125;&#125;())get() 实现私有变量function Person(name)&#123; // 定义一个私有变量 这里的意思是私房钱 var privateMoney = 20000; this.name = name; this.getPrivate = function()&#123; this.ownMoney = privateMoney &#125; this.changePrivate = function(target)&#123; privateMoney = target+privateMoney; &#125;&#125;let chris = new Person('Chris')// 看看自己有多少私房钱chris.getPrivate()console.log(chris.ownMoney)// 这里之所以可以看到是因为用到了闭包// 此时可以继续存储私房钱 chris.changePrivate(40000);chris.getPrivate()console.log(chris.ownMoney) // 此时私房钱就变成了60000// 但是我们直接去访问chris.privateMoney 是访问不到的console.log(chris,privateMoney)// 此时会报错 实现私有变量 他自己可以内部用但是我们外部访问不到 可以保存一个变量长期储存在内存中function fn()&#123; var arr = []; for(var i= 0;i&lt;=9;i++)&#123; arr[j] = function()&#123; console.log(j) &#125; &#125; return arr;&#125;var resArr = fn();resArr[1]() // 10 resArr[2]() // 10","comments":true,"tags":[]}]
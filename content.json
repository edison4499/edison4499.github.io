[{"title":"webpack-codeSpliting","date":"2019-12-03T09:23:29.138Z","path":"2019/12/03/webpack-codeSpliting/","text":"好比说项目中引入了lodashlodash 和 我们的逻辑代码就可以做一个分割 优点每次加载的文件的大小基本没变 只不过分两次加载但是由于浏览器有缓存的原因 比如第三方的lodash分开加载的话由于浏览器缓存的原因没有做改变的话是不会重新加载的这样一来就增加了开发效率 在webpack中的配置截图如下","comments":true,"tags":[]},{"title":"ts基本数据类型","date":"2019-12-03T01:50:26.681Z","path":"2019/12/03/ts基本数据类型/","text":"布尔数据类型/** * typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验， * 在typescript中主要给我们提供了以下数据类型 布尔类型（boolean） 数字类型（number） 字符串类型(string) 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 */// 布尔类型var flag:boolean = true;flag = false;// flag = 124 // 错误写法console.log(flag);// 数字类型var num:number = 123;num = 456;console.log(num); // num = 'str' // 错误写法// 字符串数据类型var str:string = 'this is ts'str = 'haha'// str = true // 错误console.log(str);// 定义数组的三种方式(数组类型)// 第一种var arr:number[] = [11,22,33]console.log(arr);// 第二种 元祖类型 属于数组的一种var arr2:Array&lt;number&gt; = [1,2,3]console.log(arr2);// var arr22:Array&lt;string&gt; = [1,2,'12'] // 错误写法// 第三种 通过anyvar arr3:any[] = [[123],123,'str']console.log(arr3);/* 枚举类型（enum） 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值， 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数], &#125;; */enum Flag &#123;success = 1,error=2&#125;;let s:Flag = Flag.success;let f:Flag = Flag.errorconsole.log(s); // 1console.log(f); // 2// 如果标识符没有赋值 它的值就是下标enum Color &#123;blue, red, 'orange'&#125;var c:Color = Color.red;console.log(c); // 1enum Car &#123;bmw,honda,jeep=3,toyota&#125;var j:Car = Car.jeepconsole.log(j); // 3var t:Car = Car.toyota;console.log(t); // 4enum Err &#123;'undefined' = -1,'null'= -2,'success'=1&#125;var e:Err = Err.success;console.log(e); // 1// 任意类型var ares:any = 123;ares = '123'ares = trueares = undefined;ares = 'any'console.log(ares);// 任意数据类型的用处var oBox:any=document.getElementById('box');oBox.style.width = '100px'oBox.style.height = '200px'oBox.style.background='red';// undefined 和 null // var unum:number;// console.log(unum); // 错误// var unum:undefined;// console.log(unum); // 正确// var unum:number | undefined;// unum = 123;// console.log(unum);// 没有赋值就是undefinedvar unum:number | undefined;console.log(unum); // undefined// null 类型var unull:null;unull = nullconsole.log(unull);// 一个元素可能是number类型 可能是null 可能是undefinedvar unumll:number | null | undefined;unumll = 1234;console.log(unumll);// void类型: typescript中的void表示没有任何类型 一般用于定义方法的时候没有返回值// es5的定义方法// function run()&#123;// console.log('run'); // &#125;// run()// ts中的写法 // function run():void&#123;// console.log('run'); // &#125;// run()// 错误的写法// function run():undefined&#123;// console.log('run'); // &#125;// A function whose declared type is neither 'void' nor 'any' must return a value.// 声明类型既不是“ void”也不是“ any”的函数必须返回一个值。// 正确的写法function returnnum():number&#123; return 124&#125;console.log(returnnum());// never类型:代表从不会出现的值。//这意味着声明never的变量只能被never类型所赋值。var a:never;// a=123; //错误的写法a=(()=&gt;&#123; throw new Error('错误');&#125;)()","comments":true,"tags":[]},{"title":"js闭包的理解","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js闭包的理解/","text":"形成闭包: 函数里面套函数，内部的函数被保存到了外部，形成闭包 特点： 内部函数可以引用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 缺点： 常驻内存增加内存使用量 使用不当很容易造成内存泄露 优点： 避免全局变量的污染var a = 123;var get = (function()&#123; var a = 345; function getAo()&#123; console.log(a) &#125; return function()&#123; getAo() &#125;&#125;())get() 实现私有变量function Person(name)&#123; // 定义一个私有变量 这里的意思是私房钱 var privateMoney = 20000; this.name = name; this.getPrivate = function()&#123; this.ownMoney = privateMoney &#125; this.changePrivate = function(target)&#123; privateMoney = target+privateMoney; &#125;&#125;let chris = new Person('Chris')// 看看自己有多少私房钱chris.getPrivate()console.log(chris.ownMoney)// 这里之所以可以看到是因为用到了闭包// 此时可以继续存储私房钱 chris.changePrivate(40000);chris.getPrivate()console.log(chris.ownMoney) // 此时私房钱就变成了60000// 但是我们直接去访问chris.privateMoney 是访问不到的console.log(chris,privateMoney)// 此时会报错 实现私有变量 他自己可以内部用但是我们外部访问不到 可以保存一个变量长期储存在内存中function fn()&#123; var arr = []; for(var i= 0;i&lt;=9;i++)&#123; arr[j] = function()&#123; console.log(j) &#125; &#125; return arr;&#125;var resArr = fn();resArr[1]() // 10 resArr[2]() // 10","comments":true,"tags":[]}]
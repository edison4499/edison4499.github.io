[{"title":"快速删除node_modules目录的方法","date":"2020-01-01T08:36:10.000Z","path":"2020/01/01/快速删除node_modules文件的方法/","text":"第一种方法 cnpm i rimraf -g rimraf node_modules 第二种方法 rmdir /s/q your_app_dir 第三种 rm -f /node_modules 第四种 cnpm install -g dlf dlf C:\\Users\\92809\\Desktop\\56（这里是node_modules的文件全路径）","comments":true,"tags":[]},{"title":"es6-Map数据结构Iterator接口","date":"2019-12-16T04:18:53.000Z","path":"2019/12/16/es6/es6-map数据结构Iterator接口/","text":"Map是什么// map????// es6 新提出的一种引用类型的数据结构 类似于对象// 字符创-》值 值-》值 声明Map数据结构const map = new Map()const o = &#123;p:'hello'&#125; // 相当于键 key map.set(o,'content') // var a = &#123;&#125; a.name = '张三' a.nameconsole.log(map.get(o)); 证明是引用数据类型// null typeof null const map = new Map()console.log(map instanceof Map); // true console.log(Object.prototype.toString.call(map) === '[object Map]'); 接收数组作为参数const map = new Map( [ ['name','张三'], ['age',18] ]) console.log(map.get('name')); // 张三 console.log(map.get('age')); // 18 // map 是数组的方法 Map 是es6新提出的一种新的 引用类型的数据结构 const m = new Map( [ [123,'abc'], ['a',&#123;x:1,y:2&#125;], [3&gt;1,666] ] ) console.log(m.get(true)); // 666 // 404 Not found 500 InterError 404和500 都是数值 let errors = new Map([ [404,'Not found'], [500,'InterError'] ]) // 注意 对象作为键名 传输的是地址 // let m1 = new Map([ // [123,'abc'], // [&#123;x:1&#125;,'cdf'] // ]) // console.log(m1.get(&#123;x:1&#125;)); // undefined let obj1 = &#123;x:1&#125; let m1 = new Map([ [123,'abc'], [obj1,'cdf'] ]) console.log(m1.get(obj1)); // cdf Map接收数组作为参数的本质// 为什么 接收一个二元数组 key value的形式 就可以通过 map.get()获取到值呢const array = [ ['name','张三'], ['age',18]]const map = new Map()array.forEach( ([key,value])=&gt;map.set(key,value)) Map参数的扩展// 具有迭代器 iterator 接口 每个成员都是双元素的数组的数据结构 都可以当做map构造函数的参数 Iterator 和 for…of 循环为什么要有iterator？？// Map Set 等数据结构 需要一个统一的接口去处理 iterator就是提供了这么一个机制 作用// 数据部署了iterator接口 就可以用for ... of 循环遍历 for…of 循环的遍历过程的本质// for...of 循环遍历的过程 // 1 创建一个指针对象 指向数据的初始位置 iterator就是一个指针对象 // 2 第一次调用指针对象的next() 可以将指针指向第一个成员 // ..... // 直到结束 // !!!! 每一次调用指针对象的时候每次调用next()方法 会返回 value 指的是值 done是布尔值 用来标识遍历是否完成 const arr = [1,2] function makeIterator(array)&#123; let nextIndex = 0; return &#123; next:function()&#123; return nextIndex &lt; array.length ? &#123; value:array[nextIndex++], done:false &#125; :&#123; value:undefined, done:true &#125; &#125; &#125; &#125; let res = makeIterator(arr) console.log(res.next()); console.log(res.next()); console.log(res.next()); console.log(res.next()); Iterator接口部署在数据结构的Symbol.iterator属性// 重中之重let arr1 = [1,2,3,4,5] // let iter = arr1[Symbol.iterator]() // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); // console.log(iter.next()); 原生具备Iterator接口的数据结构具有iterator接口 Array Map Set String 对象不具备Iterator接口 可以手动部署迭代器接口 让其可以用for…of 循环遍历// 想让对象也可以通过for...of 循环遍历 let obj = &#123; data:[1,2,3,4], [Symbol.iterator]()&#123; let index = 0 let that = this return &#123; next()&#123; if(index&lt;that.data.length)&#123; return &#123; value:that.data[index++], done:false &#125; &#125;else&#123; return &#123; value:undefined, done:true &#125; &#125; &#125; &#125; &#125; &#125; for (let i of obj )&#123; console.log(i); &#125;","comments":true,"tags":[]},{"title":"es6-函数扩展和箭头函数","date":"2019-12-16T04:18:53.000Z","path":"2019/12/16/es6/es6函数扩展箭头函数/","text":"函数扩展函数参数的默认值// 函数参数的默认值 // function get(x,y)&#123; // // 让你把y指定默认值为 '默认值' // y = y || '默认值' // console.log(x); // console.log(y); // &#125; // get(1) // 弊端 当传0的时候 打印不出实参0 // 怎么解决这个弊端？？？ // function get(x,y)&#123; // // 让你把y指定默认值为 '默认值' // if(typeof y === undefined)&#123; // y = '默认值' // &#125; // console.log(x); // console.log(y); // &#125; // get(1) // function get(x,y='默认值')&#123; // console.log(x); // console.log(y); // &#125; // get(1) function Person(name = '张三',age=18)&#123; this.name = name this.age = age &#125; let person1 = new Person() console.log(person1); // 好处 // 1 阅读代码清晰 // 2 有利于代买维护 有利于封装代码 // 注意：有默认参数声明 内部不能用let const声明 function fn(x,y=\"123\")&#123; let x = 1; &#125; fn(1) 与结构赋值结合的使用function fn(&#123;x,y=5&#125;)&#123; console.log(x); console.log(y); &#125; fn(&#123;&#125;) // undefined 5 fn(&#123;x:1&#125;) fn(&#123;x:1,y:9&#125;) // 对象解构赋值的等号的右边必须是对象 // 接口 // function api(&#123;name,pass&#125;)&#123; // // 拿到请求的数据 // console.log(name); // console.log(pass); // // 发请求 // &#125; // // 调用这个方法的数据是表单获取的数据 // // obj = &#123;name:'张三',pass:'123'&#125; // api(&#123;name:'张三',pass:'123'&#125;) function getFn([x=3,y=5])&#123; console.log(x); console.log(y); &#125; getFn([1]) function getFn([x=3,y=5] = [1])&#123; console.log(x); console.log(y); &#125; getFn() 参数默认值会形成单独的作用域// 函数的参数会形成一个单独的作用域 // 等到初始结束这个作用域就会消失 // var x =1; // function f(x,y=x)&#123; // console.log(y); // &#125; // f(2) // 相当于形成了一个单独的块级作用域 // &#123; // let x = 2 // y = x // &#125; // let x = 1; // // 相当于形成了一个单独的块级作用域 // &#123; // let y = x // console.log(y); // &#125; // function ff(y = x)&#123; // let x = 2; // console.log(y); // &#125; // function fy(y= x)&#123; // let x = 2; // console.log(y); // &#125; // fy() // 会报错 x is not defined var x = 1; // &#123; // let x = x // &#125; // function fg(x = x)&#123; // &#125; // fg() 参数展开运算符打包// 写一个方法计算 1,2,3相加的结果 用到for...of 循环 // 第一种方法 // function add()&#123; // // console.log(arguments); // // ... Array.from() // let sum = 0 // for (let i of arguments)&#123; // console.log(i); // sum += i // &#125; // return sum // &#125; // console.log(add(1,2,3)); // 第二种方法 参数展开运算符打包 function add(...values)&#123; console.log(values); let sum = 0 for (let i of values)&#123; console.log(i); sum += i &#125; return sum &#125; console.log(add(1,2,3)); 函数内部严格模式的改变// es6 函数参数指定了默认值 解构赋值 扩展运算符... 内部就不能用严格模式 ?? // 为什么 // 因为我们的参数此时也会形成一个作用域 // function get(a,b = a)&#123; // 'use strict' // &#125; // get() // ???怎么解决 // 方法一 'use strict' function get(a,b = a)&#123; &#125; get() // 方法二 const doSome = (function()&#123; 'use strict' return function(a = 2)&#123; return 2 &#125; &#125;()) 箭头函数基本用法// const f = v=&gt;v // 相当于 // const f = function(v)&#123; // return v // &#125; console.log(f(1)); // 箭头函数 // 有参数的时候 // const f = v=&gt;v // 相当于 // const f = function(v)&#123; // return v // &#125; // console.log(f(1)); // 没有参数 多个参数 需要用() 包裹起来 const fn = ()=&gt;5 console.log(fn()); const fnG = (num1,num2)=&gt;num1 + num2 console.log(fnG(1,2)); // 函数块的语句 多于一条语句的 要使用&#123;&#125; 包裹起来 并且要用return 返回 const fJ = (a,b)=&gt;&#123; let c = a+b; let d = c+19; return d &#125; console.log(fJ(1,7)); // 注意 返回的是一个对象 &#123;&#125; 此时应该怎么处理 必须要在对象的外面加括号 // let getObj = ()=&gt;(&#123;name:'张三',age:18&#125;) // console.log(getObj()); // let getObj = ()=&gt;&#123; // return &#123; // name:'张三',age:18 // &#125; // &#125; // console.log(getObj()); 注意点// 1 this 也是箭头函数作用最大的地方 this不再是动态的 定义时候所在的对象而不是使用时所在的对象 // 2 箭头函数不能当做构造函数 不能new // 3 箭头函数内部不能用 arguments // 4 不能够当做 generator函数 不能加yield命令 实例演示// 见跑马灯的代码// Person.prototype.say = ()=&gt;&#123; // console.log(`我的名字是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁了`); // &#125; // function Person()&#123; // this.name = '张飞' // this.age = 33 // &#125; // let person1 = new Person() // person1.say() // const hander = &#123; // id:12, // init:function()&#123; // setTimeout(()=&gt;&#123; // console.log(this); // this.doSome() // &#125;,1000) // &#125;, // doSome:function()&#123; // console.log(`初始化的id为$&#123;this.id&#125;`); // &#125; // &#125; // hander.init() function Person()&#123; this.name = '张三' this.say = function()&#123; console.log(`这是我的名字$&#123;this.name&#125;`); &#125; this.say = this.say.bind(this) // this.say = ()=&gt;&#123; // console.log(`这是我的名字$&#123;this.name&#125;`); // &#125; &#125; let person = new Person() let res = person.say res() // 为以后学习react 打下基础 学习class打下基础 使用时机// 箭头函数的使用时机 // 1 如果说有一个简短的语句 返回是一个简单的表达式 return num + num 2 函数内部没有this的引用 // 也没有自身的引用 (递归) // 2 内部需要 调用vat self = this 调用 bind 也适用于箭头函数 // 3 只要是回调函数 99% 用箭头函数就没有错","comments":true,"tags":[]},{"title":"webpack之splitChunks的配置详解","date":"2019-12-16T04:00:53.000Z","path":"2019/12/16/splitChunks的配置详解/","text":"optimization:&#123; splitChunks:&#123; chunks: 'all', // all 所有 async 异步 initial 同步 minSize: 30000,// 最小的字节大小这里是30kb // maxSize: 0,// 最大的 这一项一般不用 意思是假设打包的有1mb 这里设置500000 // 会尝试进行二次的拆分 minChunks: 1, // 引入的块的最小值 比如说这里只引入了lodash如果这里改成2的话 就不会做代码分割了 maxAsyncRequests: 6,// 最大的代码分割数 比如说你引入了7个 但是这里设置6 只会对前6个做分割 maxInitialRequests: 4,// 整个网站首页加载的时候的最大引入数 automaticNameDelimiter: '~', // 打包后文件名字的连接符号 automaticNameMaxLength: 30, // 设置块名称的最大字符 name:true, // 指的是下面的filename的名字生效 cacheGroups: &#123; // 缓存组 代码分割后的非业务逻辑代码打包到一起 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, //检测是否在node_modules目录 priority: -20, // 这个是优先级和下面default的priority做对比 // 引入的lodash符合在nodemodules下面 // filename:'[name].bundle.js' name:'vendor' &#125;, default: &#123;// 检测的是没有在node_modules 目录下的时候的处理 minChunks: 2,// 引入块的最小值 priority: -10,// 优先级 // 引入的lodash也符合在default 所有的模块都符合 此时就是比较权重了 // 注意哪怕这里的权重比上面的高 但是被上面的test匹配到了之后还是会走上面的 reuseExistingChunk: true, // 比如说有两个模块 a 和 b a里面引入的有b // 正常来说打包a的话会把b也打包进去 // 但是假如说以前b已经被打包过了 那么就不会再次被打包进去了 name:'common' &#125; &#125; &#125;&#125;","comments":true,"tags":[]},{"title":"webpack之code-spliting","date":"2019-12-12T04:00:53.000Z","path":"2019/12/12/webpack-codeSpliting/","text":"好比说项目中引入了lodashlodash 和 我们的逻辑代码就可以做一个分割 优点每次加载的文件的大小基本没变 只不过分两次加载但是由于浏览器有缓存的原因 比如第三方的lodash分开加载的话由于浏览器缓存的原因没有做改变的话是不会重新加载的这样一来就增加了开发效率 在webpack中的配置截图如下","comments":true,"tags":[]},{"title":"es6-reflect","date":"2019-12-10T09:25:53.000Z","path":"2019/12/10/es6/es6-reflect/","text":"Reflect是什么？为操作对象而提供的新API 为什么要设计Reflect？ 将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。 让Object操作变成函数行为// 以前const obj = &#123;name:'张三'&#125;console.log('name' in obj); // true// 现在console.log(Reflect.has(obj,'name')); // true Reflect 与 Proxy 是相辅相成的 在Proxy上有的方法 在 Reflect上就一定有Reflect的api 和proxy的api一致 Reflect.get(target,property,receiver)查找并返回target对象的property属性let obj=&#123; name:\"chris\",&#125;let result=Reflect.get(obj,\"name\")console.log(result) //chrislet obj=&#123; //属性yu部署了getter读取函数 get yu()&#123; //this返回的是Reflect.get的receiver参数对象 return this.name+this.age &#125;&#125;let receiver=&#123; name:\"shen\", age:\"18\",&#125;let result=Reflect.get(obj,\"yu\",receiver)console.log(result) //shen18 Reflect.set(target,propName,propValue,receiver)设置target对象的propName属性为propValuelet obj=&#123; name:\"chen\"&#125;let result=Reflect.set(obj,\"name\",\"shi\")console.log(result) //trueconsole.log(obj.name) //shilet obj=&#123; age:38, set setAge(value)&#123; return this.age=value &#125;&#125;let receiver=&#123; age:28&#125;let result=Reflect.set(obj,\"setAge\",18,receiver)console.log(result) //trueconsole.log(obj.age) //38console.log(receiver.age) //18 Reflect.set与Proxy.set联合使用let obj=&#123; name:\"chen\"&#125;let handler=&#123; set(target,key,value,receiver)&#123; console.log(\"Proxy拦截赋值操作\") //Reflect完成赋值操作 Reflect.set(target,key,value,receiver) &#125;, defineProperty(target,key,attribute)&#123; console.log(\"Proxy拦截定义属性操作\") //Reflect完成定义属性操作 Reflect.defineProperty(target,key,attribute) &#125;&#125;let proxy=new Proxy(obj,handler)proxy.name=\"ya\"//Proxy拦截赋值操作//Proxy拦截定义属性操作","comments":true,"tags":[]},{"title":"es6-对象的扩展Symbol Set数据结构","date":"2019-12-09T02:22:53.000Z","path":"2019/12/09/es6/es6对象的扩展Symbol-Set数据结构/","text":"对象的扩展方法属性的简写const a = 'a';const obj = &#123;a&#125;// const obj = &#123;a:a&#125;console.log(obj); 方法的简写const o = &#123; say()&#123; return '我是chris' &#125;&#125;console.log(o.say());// 谁用我我就指向谁var name = '全局'const person = &#123; name:'张三', say()&#123; console.log(`我的名字是$&#123;this.name&#125;`); &#125;&#125;person.say()let res = person.say; // 全局res() 属性名表达式let obj1 = &#123; // 让属性和变量挂钩 [key]:true, ['o'+'b']:123, [`ok`]:456&#125;console.log(obj1); super 关键字const proto = &#123; foo:'土豆'&#125;// const oProto = &#123;// foo:'西红柿',// find()&#123;// return super.foo// &#125;// &#125;// // proto 是 oProto的原型// Object.setPrototypeOf(oProto,proto) // __proto__// console.log(oProto.find()); // // const oProto = &#123;// foo:super.foo// &#125; 对象的扩展运算符 …打包// 打包// let &#123;x,y:y,...z&#125; = &#123;x:1,y:2,a:3,b:4&#125;// console.log(z);// 等号的右边必须是一个对象 // let &#123;...h&#125; = undefined// let &#123;...v&#125; = null// 数组的解构赋值 ... 有一个注意点 是...的位置// let &#123;...z,x,y&#125; = &#123;x:1,y:2,a:3,b:4&#125; 拆包// 复制 浅拷贝 深拷贝 // 数组的浅拷贝es5 用到的是什么 concat // 对象的扩展运算符 ...也是浅拷贝 // 复制 // let obj = &#123;a:1&#125; // // let obj1 = obj; // // obj1.a = 2; // // console.log(obj); // // 浅拷贝 // let obj1 = &#123;...obj&#125; // obj1.a = 2; // console.log(obj); // // es5 实现浅拷贝 类比concat // let person = &#123;name:'张三',age:12&#125; // let person2 = Object.assign(&#123;&#125;,person) // person2.name = '王五' // console.log(person); // let &#123;a,b,...z&#125; = &#123;c:1,b:2,a:3,d:4&#125; // console.log(z); // 是不是深拷贝？ 不是！！！ let obj = &#123;a:&#123;b:1&#125;&#125; let obj1 = &#123;...obj&#125; obj1.a.b =2; console.log(obj); Symbol数据结构概念以及引入的原因// 新提出的一个数据结构 Symbol 基本数据类型 // Symbol表示独一无二 第七种数据类型 // 作用？ // 对象的属性是字符串 对象的话隐式调用toString 转化成字符串 let a = &#123;a:1&#125;; let b = &#123;b:2&#125;; let c = &#123;&#125;; c[a] = 3; // [object Object] c[b] = 4; // [object Object] console.log(c); // ? 怎么解决 let s = Symbol() console.log(typeof s); // 第七种一般数据类型 接收字符串作为参数let s1 = Symbol('a') let s2 = Symbol('b') console.log(s1); console.log(s2); console.log(s1.toString()); console.log(s2.toString()); let s3 = Symbol(&#123;&#125;) console.log(s3); // 传入的参数只是值得描述 即使传入的值是一样的 返回值也是不相等的 let s4 = Symbol() let s5 = Symbol(); console.log(s4 === s5); let s6 = Symbol('a') let s7 = Symbol('a'); console.log(s6 === s7); 不能与其他类型的值进行计算let sym = Symbol('my Symbol') 'my symbol is' + sym Symbol可以显示转化为字符串let s1 = Symbol('a')let s2 = Symbol('b')console.log(s1);console.log(s2);console.log(s1.toString());console.log(String(s1)); Symbol可以转为布尔值 但是不能转化成数值 let symb = Symbol();console.log( !Boolean(symb)); Symbol.iterator 属性对象的Symbol.iterator属性 指向该对象的默认遍历器的方法 for...of 循环的时候会调用Symbol.iterator Object.getOwnPropertySymbols()const obj = &#123;&#125;; let sym1 = Symbol('a') let sym2 = Symbol('b') obj[sym1] = 'hello' obj[sym2] = 'world' // Object.getOwnPropertySymbols() 返回一个数组 里面的值是所有用作属性名的Symbol的值 const arr = Object.getOwnPropertySymbols(obj) console.log(arr); 作用实例 常量枚举 私有属性// // js没有枚举类型 用到枚举案例的时候可以用到 Symbol类型// const CODE_ONE = 1; // 汽车的颜色 红色// const CODE_TWO = 1;// 蓝色// const CODE_THREE = 3;// 黑色// const CODE_ONE = Symbol('a'); // 汽车的颜色 红色// const CODE_TWO = Symbol('b');// 蓝色// const CODE_THREE = Symbol('b');// 黑色// // 会实现私有属性 const private = Symbol('private') const obj = &#123; // 私有属性 _name:'张三', [private]:'私有的属性' &#125; console.log(Object.keys(obj)); // 到底怎么实现私有属性呢？ class 里面的一些东西 会详细讲到 Set数据结构Set是什么// Set是es6新提出的一个新的引用数据类型 类似于数组 但是成员是唯一的 没有重复的值// 和对象里面的 get set 不一样 基本用法// 基本用法 const set = new Set([1,2,3,4,5,6,5]) console.log(set); 证明set是js新的引用数据类型let arr = [1,2,3,4]let obj = &#123;name:'张三'&#125;let nu = null // 历史遗留问题console.log(typeof arr);console.log(typeof obj);console.log(typeof nu);// 证明 arr是数组 obj 是对象// instanceof // Object.prototype.toString.call(arr)console.log(arr instanceof Array);console.log(obj instanceof Object);console.log(Object.prototype.toString.call(arr)); // string [object Array]console.log(Object.prototype.toString.call(obj)); // string [object Object]const set = new Set([1,2,3,4,5,6,5])console.log(set instanceof Set);console.log(Object.prototype.toString.call(set) === '[object Set]'); 转化成数组// 转化成数组 const set = new Set([1,2,3,4,5,6,5]) // 数组去重的方法 console.log([...set]); console.log(Array.from(set)); Set数据内部判断值得机制// Set数据内部判断值得机制 类似于 === let newSet = new Set() let a = 5; let b = '5' newSet.add(a) newSet.add(b) // ? 里面有几项 ？ console.log(newSet); // 特殊情况NaN // 因为 NaN === NaN newSet.add(NaN) newSet.add(NaN) console.log(newSet); Set实例的属性和方法Set的属性let lastSet = new Set()lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN)console.log(lastSet.size); add delete has clearlet lastSet = new Set() lastSet.add(1).add(2).add(2).add('2').add(NaN).add(NaN) console.log(lastSet.size); // 判断是否有这一项 console.log(lastSet.has(2)); lastSet.clear() console.log(lastSet); 方法forEach()let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9","comments":true,"tags":[]},{"title":"es6-字符串数组的扩展方法","date":"2019-12-07T05:05:53.000Z","path":"2019/12/07/es6/es6字符串数组的扩展/","text":"字符串的扩展方法模板字符串简便换行和嵌入变量操作// 简便换行 let s1 = '我爱我的祖国\\n和我的母亲' console.log(s1); let s2 = `我爱我的祖国和我的母亲` console.log(s2); let a = '和我的母亲' let b = '我爱我的祖国'+a+'还有我的妻子' console.log(b); let b1 = `我爱我的祖国$&#123;a&#125;还有我的妻子` console.log(b1); 调用函数// 调用函数 function fn()&#123; return '祖国' &#125; console.log(`亲爱的$&#123;fn()&#125;你好`); 模板字符串嵌套// 支持嵌套 let arr = [1,2,3] const str = (arr)=&gt;` 我是一级字符串 $&#123;arr.map(v=&gt;`$&#123;v&#125;`)&#125; ` console.log(str(arr)); 注意点`\\`` 新增的实例方法includes() startsWith() endsWith()// includes()返回布尔值 startsWith() endsWith() let s = 'hello world' console.log(s.includes('o')); console.log(s.includes('p')); console.log(s.startsWith('hello')); console.log(s.endsWith('world')); // 支持第二个参数 表示开始搜索的位置 从o0开始的 console.log( s.startsWith('world',6)); console.log( s.startsWith('world',7)); repeat()// repeat() console.log('x'.repeat(3)); console.log('hello'.repeat(3)); padStart() padEnd()console.log('x'.padStart(5,'ab')); // 总得长度 从开始位置填充的东西 // 提示字符串的格式console.log('17'.padStart(10,'YYYY-MM-DD'));console.log('12-06'.padStart(10,'YYYY-MM-DD')); 数组的扩展方法展开运算符 … 拆包函数调用的体现function f(a,b,c)&#123; console.log(a); console.log(b); console.log(c); &#125; var args = [1,2,3] // f.apply(null,args) // 拆包 // console.log(...args); f(...args) 后面可以放表达式let a = 1; const arr = [ ...(a&gt;0? ['a']: []) ] console.log(arr); 替代函数的apply方法// 思考连接两个数组的方法 let arr1 = [1,2,3] let arr2 = [4,5,6] console.log(arr1.concat(arr2)); console.log(arr1); // ? 想让原来的数组改变 // es5的想到的话 你的基本功也很扎实 // es5 解决办法 Array.prototype.push.apply(arr1,arr2); console.log(arr1); // es6 // (...arr1) += (...arr2) // 扩展运算符只有函数调用的时候才可以放在圆括号当中 // (...[1,2]) // console.log((...[1,2])); arr1.push(...arr2); console.log(arr1); 复制数组const a1 = [1,2]const a2 = a1;// 复制console.log(a1 === a2);// 指向同一个房间// a2[0] = 2// console.log(a1);// 是不是浅克隆？这不是浅克隆 这叫复制// 浅克隆是长得一样 但是地址不一样const a3 = a1.concat()// 浅拷贝console.log(a3);console.log(a1 === a3);// 没有指向同一个房间 const a4 = [...a1]console.log(a4);console.log(a4 === a1);// 浅拷贝// 展开运算符是浅拷贝 而不是 深拷贝let arr = [&#123;a:1&#125;,2,3]// let arr1 = [...arr] // 是深拷贝嘛？// arr1[0].a = 2// // 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝// console.log(arr); // // 深拷贝 除了递归能实现let arr2 = JSON.parse(JSON.stringify(arr))arr2[0].a = 2;// 如果此时arr[0].a = 2 说明是浅拷贝 不等于2 说明是深拷贝console.log(arr); …打包// const [first,...arr] = [1,2,3,4,5] // console.log(arr); // const [o,...s] = []; // console.log(o) // undefined // console.log(s) // [] // 只能放在参数的最后一位 // const [...arr,first] = [1,2,3,4,5] Array.from()// Array.from() 用于把类数组对象转化成真正的数组 // 部署了 iterator 接口 都可以用Array.from()转化成真正的数组 // 有 length属性 没有数组操作的一些方法 push function get(a,b,c)&#123; console.log(arguments); console.log(Array.from(arguments)); &#125; get(1,2,3) const copyArr = &#123; '0':'a', '1':'b', length:2 &#125; console.log(Array.from(copyArr)); Array.of()// 可以将一组值转化成数组 console.log(Array.of(2,3,4,5)); // ？ 弥补数组构造函数的一些不足 console.log(Array(3).length); // 当参数不少于2个时候 console.log(Array(1,2,3)); console.log(Array.of(3)); copyWithin()// copyWithin() // 1 必须要传的 从该位置开始替换数据 // 2 start 从该位置读取数据 默认是0 // 3 end console.log([1,2,3,4,5].copyWithin(0,3)); // [4,5,3,4,5] find() findIndex()let arr = [1,2,3,-1,-2,45] let res = arr.find(function(i)&#123; return i&lt;0 &#125;) console.log(res); let resIndex = arr.findIndex(function(i)&#123; return i&lt;0 &#125;) console.log(resIndex) 作业分别用 includes() find() findIndex()实现数组的去重 let arr = [1,2,3,4,1,3,5,7,89,45,23,1]","comments":true,"tags":[]},{"title":"数组去重","date":"2019-12-06T03:10:53.000Z","path":"2019/12/06/js面试题/","text":"let arr = [1,2,3,4,1,3,5,7,89,45,23,1]function uniqueOne(arr) &#123; if (!Array.isArray(arr)) &#123; console.log('type error!') return &#125; var array =[]; for(var i = 0; i &lt; arr.length; i++) &#123; if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值 array.push(arr[i]); &#125; &#125; return array&#125;console.log(uniqueOne(arr))function uniqueTwo(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if(!arrs.find((v)=&gt;&#123; return v==array[i] &#125;))&#123; arrs.push(array[i]) &#125; &#125; return arrs; &#125;console.log(uniqueTwo(arr))function uniqueThree(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if (arrs.indexOf(array[i]) == -1)&#123; arrs.push(array[i]) &#125;; &#125; return arrs; &#125; console.log(uniqueThree(arr))function uniqueFour(array)&#123; //一个新的数组 var arrs = []; //遍历当前数组 for(var i = 0; i &lt; array.length; i++)&#123; //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 if(arrs.findIndex((v)=&gt;&#123; return v == array[i] &#125;)==-1)&#123; arrs.push(array[i]) &#125; // if(arrs.findIndex(function(v)&#123; // return v == array[i] // &#125;)==-1)&#123; // arrs.push(array[i]) // &#125; &#125; return arrs; &#125;console.log(uniqueFour(arr))","comments":true,"tags":[]},{"title":"es6-块级作用域 解构赋值","date":"2019-12-06T03:10:53.000Z","path":"2019/12/06/es6/es6块级作用域解构赋值/","text":"1. es6的背景介绍ES6是什么？ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了和js之间的关系ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。作用是使得JavaScript语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。（更具模块化） 2. let const var2.1. 不存在变量提升// es5// 1 全程扫描一下错误 2 预编译环节console.log(a); // undefinedvar a = 123// es6 console.log(b);let b = 456;console.log(b); 2.2. 暂时性死区2.2.1. let死区var tep = 890;if(true)&#123; tep = 'abc' let tep&#125; 2.2.2. typeof 不再是百分百报错// typeof 不再是完全正确的console.log(typeof c);let c; 2.2.3. 不允许重复声明let e = 123;let e = 456// 'e' has already been declared 2.3. 块级作用域2.3.1. 为什么要有块级作用域？ // 内层的变量会覆盖外层的变量var a = '全局'function fn()&#123; // 预编译 找var a // var a console.log(a); // undefined if(false)&#123; var a = '局部' &#125;&#125;fn()// 复习预编译的东西// 全局 函数作用 块级作用域（在各自的块干自己的事情 不影响）var a = '全局';(function()&#123; var a = '局部' console.log(a); &#125;())console.log(a) let a = '全局'&#123; let a = '局部' console.log(a);&#125;console.log(a); 2.3.2. 允许作用域的任意嵌套// 允许作用域的任意嵌套&#123; &#123; let b = '局部' &#125; console.log(b); // b is not defined&#125;&#123; &#123; let b = '局部' &#123; console.log(b); &#125; &#125;&#125; 2.3.3. 注意if(true)&#123; let x = 1;&#125; // 不会报错if(true) let y = 2 // 会报错// Lexical declaration cannot appear in a single-statement context 2.3.4. 开发中具体的例子2.4. const 特殊的地方2.4.1. 声明常量不能变const a = 123;a = '123'const b = true;b = false 2.4.2. 本质// 引用数据类型可以变变得是堆里面的内容 不变的是地址const obj = &#123;name:'chris',age:33&#125; console.log(obj);obj = &#123;name:'Chris',age:33&#125; 2.4.3. 可以冻结对象// const foo = Object.freeze(&#123;&#125;)// foo.name = '大白菜'// console.log(foo);'use strict'const foo = Object.freeze(&#123;&#125;)foo.name = '大白菜' 2.5. 全局的缺陷 // new Array()console.log(window.Array);var Array = '这是数组'console.log(window.Array);var a = '123'console.log(window.a); // 123let b = '全局'console.log(window.b); // undefined// let 提出后 全局变量和顶层对象的属性 脱钩 3. 解构赋值3.1. 数组解构赋值// 通过数组对变量进行赋值let arr = [1,2,3]console.log(arr[0]);console.log(arr[1]);console.log(arr[2]);let [a,b,c] = [1,2,3]console.log(a);console.log(b);console.log(c); 3.1.1. 模式匹配等号两边的模式相同 左边的变量就会被赋予对应的值 let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.2. 不完全解构// 不完全解构 let [x,y,u] = [1,2,3,4] console.log(x); console.log(y); console.log(u); 3.1.3. 嵌套模式let [a,[[b],c]] = [1,[[2],3]] console.log(a); console.log(b); console.log(c); 3.1.4. 默认值// 指定默认值 let [f = true] = [] console.log(f); let [a,b=\"y\"] = ['a'] console.log(b); // 注意点 es6内部使用 === 判断是否是undefined 如果是undefined 默认值才会生效 let [x = 1] = [null] let [y = 2] = [undefined] console.log(x); // null console.log(y); // 2 3.1.4.1. 惰性求值// 惰性求值 function f()&#123; return 'fff' &#125; // let [x = f()] = [1] let [x = f()] = [] console.log(x); 3.1.4.2. 默认值可以引用解构赋值的其他变量// 默认值可以引用解构赋值的其它变量 前提是变量必须已经声明 // let [x= 1,y=x] = [] // console.log(x); // 1 // console.log(y); // let [x = y,y=1] = [] // 从左往右 // let [y = 1 , x = y] = [] // console.log(x); // console.log(y); 3.2. 对象解构赋值3.2.1. 定义用法注意点let person = &#123; name:\"chris\", age:33 &#125; // let &#123;name,age&#125; = person; // 注意：对象的解构和数组不一样 和顺序无关 let &#123;age:age,name:name&#125; = person; console.log(name); console.log(age); let &#123;sex&#125; = person; console.log(sex); // 解构不成功会返回undefined // 真正被赋值的是后者 对象解构赋值的实质 // 会先找到同名的属性 赋值给后者的变量 let &#123;name:name1&#125; = person console.log(name1); 3.2.2. 可以取到继承的属性const obj1 = &#123;&#125;;const obj2 = &#123;name:'laney'&#125;Object.setPrototypeOf(obj1,obj2)// obj1.__proto__ = obj2const &#123;name&#125; = obj1;console.log(name); 3.2.3. 指定默认值// 默认值的生效条件 对象属性的值 严格 === undefinedconst &#123;x = 1&#125; = &#123;x:undefined&#125;const &#123;y = 3&#125; = &#123;y:null&#125;console.log(x);console.log(y); 作业// 作业题 const items = [ ['name','张飞'], ['title','长坂坡一声吼'] ] // 循环数组 分别打印 第二层数组的值 用数组的解构来做","comments":true,"tags":[]},{"title":"ts的基本数据类型","date":"2019-12-03T01:50:26.681Z","path":"2019/12/03/ts基本数据类型/","text":"布尔数据类型/** * typescript中为了使编写的代码更规范，更有利于维护，增加了类型校验， * 在typescript中主要给我们提供了以下数据类型 布尔类型（boolean） 数字类型（number） 字符串类型(string) 数组类型（array） 元组类型（tuple） 枚举类型（enum） 任意类型（any） null 和 undefined void类型 never类型 */// 布尔类型var flag:boolean = true;flag = false;// flag = 124 // 错误写法console.log(flag);// 数字类型var num:number = 123;num = 456;console.log(num); // num = 'str' // 错误写法// 字符串数据类型var str:string = 'this is ts'str = 'haha'// str = true // 错误console.log(str);// 定义数组的三种方式(数组类型)// 第一种var arr:number[] = [11,22,33]console.log(arr);// 第二种 元祖类型 属于数组的一种var arr2:Array&lt;number&gt; = [1,2,3]console.log(arr2);// var arr22:Array&lt;string&gt; = [1,2,'12'] // 错误写法// 第三种 通过anyvar arr3:any[] = [[123],123,'str']console.log(arr3);/* 枚举类型（enum） 随着计算机的不断普及，程序不仅只用于数值计算，还更广泛地用于处理非数值的数据。 例如：性别、月份、星期几、颜色、单位名、学历、职业等，都不是数值数据。 在其它程序设计语言中，一般用一个数值来代表某一状态，这种处理方法不直观，易读性差。 如果能在程序中用自然语言中有相应含义的单词来代表某一状态，则程序就很容易阅读和理解。 也就是说，事先考虑到某一变量可能取的值，尽量用自然语言中含义清楚的单词来表示它的每一个值， 这种方法称为枚举方法，用这种方法定义的类型称枚举类型。 enum 枚举名&#123; 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数], &#125;; */enum Flag &#123;success = 1,error=2&#125;;let s:Flag = Flag.success;let f:Flag = Flag.errorconsole.log(s); // 1console.log(f); // 2// 如果标识符没有赋值 它的值就是下标enum Color &#123;blue, red, 'orange'&#125;var c:Color = Color.red;console.log(c); // 1enum Car &#123;bmw,honda,jeep=3,toyota&#125;var j:Car = Car.jeepconsole.log(j); // 3var t:Car = Car.toyota;console.log(t); // 4enum Err &#123;'undefined' = -1,'null'= -2,'success'=1&#125;var e:Err = Err.success;console.log(e); // 1// 任意类型var ares:any = 123;ares = '123'ares = trueares = undefined;ares = 'any'console.log(ares);// 任意数据类型的用处var oBox:any=document.getElementById('box');oBox.style.width = '100px'oBox.style.height = '200px'oBox.style.background='red';// undefined 和 null // var unum:number;// console.log(unum); // 错误// var unum:undefined;// console.log(unum); // 正确// var unum:number | undefined;// unum = 123;// console.log(unum);// 没有赋值就是undefinedvar unum:number | undefined;console.log(unum); // undefined// null 类型var unull:null;unull = nullconsole.log(unull);// 一个元素可能是number类型 可能是null 可能是undefinedvar unumll:number | null | undefined;unumll = 1234;console.log(unumll);// void类型: typescript中的void表示没有任何类型 一般用于定义方法的时候没有返回值// es5的定义方法// function run()&#123;// console.log('run'); // &#125;// run()// ts中的写法 // function run():void&#123;// console.log('run'); // &#125;// run()// 错误的写法// function run():undefined&#123;// console.log('run'); // &#125;// A function whose declared type is neither 'void' nor 'any' must return a value.// 声明类型既不是“ void”也不是“ any”的函数必须返回一个值。// 正确的写法function returnnum():number&#123; return 124&#125;console.log(returnnum());// never类型:代表从不会出现的值。//这意味着声明never的变量只能被never类型所赋值。var a:never;// a=123; //错误的写法a=(()=&gt;&#123; throw new Error('错误');&#125;)()","comments":true,"tags":[]},{"title":"js闭包的理解","date":"2019-11-29T07:00:23.000Z","path":"2019/11/29/js闭包的理解/","text":"形成闭包: 函数里面套函数，内部的函数被保存到了外部，形成闭包 特点： 内部函数可以引用外部函数的参数和变量 参数和变量不会被垃圾回收机制回收 缺点： 常驻内存增加内存使用量 使用不当很容易造成内存泄露 优点： 避免全局变量的污染var a = 123;var get = (function()&#123; var a = 345; function getAo()&#123; console.log(a) &#125; return function()&#123; getAo() &#125;&#125;())get() 实现私有变量function Person(name)&#123; // 定义一个私有变量 这里的意思是私房钱 var privateMoney = 20000; this.name = name; this.getPrivate = function()&#123; this.ownMoney = privateMoney &#125; this.changePrivate = function(target)&#123; privateMoney = target+privateMoney; &#125;&#125;let chris = new Person('Chris')// 看看自己有多少私房钱chris.getPrivate()console.log(chris.ownMoney)// 这里之所以可以看到是因为用到了闭包// 此时可以继续存储私房钱 chris.changePrivate(40000);chris.getPrivate()console.log(chris.ownMoney) // 此时私房钱就变成了60000// 但是我们直接去访问chris.privateMoney 是访问不到的console.log(chris,privateMoney)// 此时会报错 实现私有变量 他自己可以内部用但是我们外部访问不到 可以保存一个变量长期储存在内存中function fn()&#123; var arr = []; for(var i= 0;i&lt;=9;i++)&#123; arr[j] = function()&#123; console.log(j) &#125; &#125; return arr;&#125;var resArr = fn();resArr[1]() // 10 resArr[2]() // 10","comments":true,"tags":[]}]